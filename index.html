<html lang="en">

<header>
  <title>SYMMIO</title>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script>
    // ---------------Caption visibility scroll
    window.addEventListener("scroll", function () {
      var scrollPosition = window.scrollY || document.documentElement.scrollTop;
      var scrollThreshold1 = window.innerHeight * 0.2; // page number to lower oppacity

      if (scrollPosition <= scrollThreshold1) {
        // If scrolled 50% or more, hide the element with an ease-out effect
        document.querySelector(".caption").style.opacity = "1.0";
      } else {
        document.querySelector(".caption").style.opacity = "0.0";
      }
    });
    // ---------------CaptionMobile visibility scroll
    window.addEventListener("scroll", function () {
      var scrollPosition = window.scrollY || document.documentElement.scrollTop;
      var scrollThreshold1 = window.innerHeight * 0.2; // page number to lower oppacity

      if (scrollPosition <= scrollThreshold1) {
        // If scrolled 50% or more, hide the element with an ease-out effect
        document.querySelector(".captionMobile").style.opacity = "1.0";
      } else {
        document.querySelector(".captionMobile").style.opacity = "0.0";
      }
    });


    /*--------ScrollDown visibility-------*/

    window.addEventListener("scroll", function () {
      var scrollPosition = window.scrollY || document.documentElement.scrollTop;
      var scrollThreshold1 = window.innerHeight * 0.5; // page number to lower oppacity
      var scrollThreshold2 = window.innerHeight * 8.0; // page number to hide

      if (scrollPosition <= scrollThreshold1) {
        // If scrolled 50% or more, hide the element with an ease-out effect
        document.querySelector(".scrollDown").style.opacity = "1.0";
      } else if (scrollPosition <= scrollThreshold2) {
        // Otherwise, show the element with ease-in effect
        document.querySelector(".scrollDown").style.opacity = "0.2";
      } else {
        document.querySelector(".scrollDown").style.opacity = "0.0";
      }
    });



    ///////--------------------------- Big screen menu settings
    $(document).on("click", 'a[href^="#"]', function (event) {
      event.preventDefault();

      $("html, body").animate(
        {
          scrollTop: $($.attr(this, "href")).offset().top,
        },
        500
      );
    });

    $(document).ready(function () {
      function isElementInViewport(elem) {
        var rect = elem.getBoundingClientRect();
        return (
          rect.top >= 0 &&
          rect.bottom <=
          (window.innerHeight || document.documentElement.clientHeight)
        );
      }

      function activateMenuItem() {
        $(".section").each(function () {
          if (isElementInViewport(this)) {
            var sectionId = $(this).attr("id");
            $(".menu__item").removeClass("menu__item--current");
            $(".menu__link[href='#" + sectionId + "']")
              .parent()
              .addClass("menu__item--current");
          }
        });
      }

      function activateMenuItem() {
        var scrollPosition = $(window).scrollTop();

        $(".section").each(function () {
          var sectionId = $(this).attr("id");
          var sectionTop = $(this).offset().top;
          var sectionHeight = $(this).outerHeight();

          if (
            scrollPosition >= sectionTop &&
            scrollPosition < sectionTop + sectionHeight
          ) {
            $(".menu__item").removeClass("menu__item--current");
            $(".menu__link[href='#" + sectionId + "']")
              .parent()
              .addClass("menu__item--current");
          }
        });
      }

      activateMenuItem();

      $(window).on("scroll", function () {
        activateMenuItem();
      });

      $(document).on("click", ".menu__link", function (event) {
        event.preventDefault();

        var target = $($(this).attr("href"));

        if (target.length) {
          $("html, body").animate(
            {
              scrollTop: target.offset().top,
            },
            500
          );
        }
      });
    });

    $(document).on("click", 'button[href^="#"]', function (event) {
      event.preventDefault();

      $("html, body").animate(
        {
          scrollTop: $($.attr(this, "href")).offset().top,
        },
        500
      );
    });

    function setup() {
      $(".menu__item").first().addClass("menu__item--current");
    }

    $(document).on("click", ".menu__link", function (event) {
      event.preventDefault();

      var target = $($(this).attr("href"));

      if (target.length) {
        $("html, body").animate(
          {
            scrollTop: target.offset().top,
          },
          1000
        );
      }
    });
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>

  <script src="https://unpkg.com/gsap@3.5.1/dist/ScrollTrigger.min.js"></script>
  <script src="https://unpkg.com/gsap@3.5.1/dist/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.4.0/TextPlugin.min.js"></script>
  <script>function updateScrollProgress() {
      const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
      const currentScroll = window.scrollY;
      scrollProgress = currentScroll / maxScroll;

      if (uniforms && uniforms.iScrollProgress) {
        uniforms.iScrollProgress.value = scrollProgress;
      }
    }



    // Set up content scroll triggers
    function setupContentScrollTrigger() {
      const content = [
        {
          list_top: "",
          title: "",
          subtitle: "Reimagining bilateral OTC Derivatives by combining them with Intent-Based execution. Allowing permissionless leverage trading of any asset, with hyperefficient just-in-time liquidity.",
          titleSYMM: "SYMMIO",
          list_top: "",
          selector: ".section.one"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>HOW TO TRADE INTENTs</span> "
            + "</br></br>"
            + " <span>• Formulate and create your INTENT</span></br>"
            + " <span>• Send your INTENT to the pool</span></br>"
            + " <span>• HEDGERs see your INTENT</span></br>"
            + " <span>• A HEDGER accepts your INTENT</span></br>"
            + " <span>• INTENTs make up the trade</span>",
          selector: ".section.two"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>HOW TO TRADE INTENTs</span> "
            + "</br></br>"
            + " <span class=active-span>• Formulate and create your INTENT</span></br>"
            + " <span>• Send your INTENT to the pool</span></br>"
            + " <span>• HEDGERs see your INTENT</span></br>"
            + " <span>• A HEDGER accepts your INTENT</span></br>"
            + " <span>• INTENTs make up the trade</span>",
          selector: ".section.three"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>HOW TO TRADE INTENTs</span> "
            + "</br></br>"
            + " <span>• Formulate and create your INTENT</span></br>"
            + " <span class=active-span>• Send your INTENT to the pool</span></br>"
            + " <span>• HEDGERs see your INTENT</span></br>"
            + " <span>• A HEDGER accepts your INTENT</span></br>"
            + " <span>• INTENTs make up the trade</span>"
            + "</br></br>",
          selector: ".section.four"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>HOW TO TRADE INTENTs</span> "
            + "</br></br>"
            + " <span>• Formulate and create your INTENT</span></br>"
            + " <span>• Send your INTENT to the pool</span></br>"
            + " <span class=active-span>• HEDGERs see your INTENT</span></br>"
            + " <span>• A HEDGER accepts your INTENT</span></br>"
            + " <span>• INTENTs make up the trade</span>",
          selector: ".section.five"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>HOW TO TRADE INTENTs</span>"
            + "</br></br>"
            + " <span>• Formulate and create your INTENT</span></br>"
            + " <span >• Send your INTENT to the pool</span></br>"
            + " <span>• HEDGERs see your INTENT</span></br>"
            + " <span class=active-span>• A HEDGER accepts your INTENT</span></br>"
            + " <span>• INTENTs make up the trade</span>",
          selector: ".section.six"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>HOW TO TRADE INTENTs</span> "
            + "</br></br>"
            + " <span>• Formulate and create your INTENT</span></br>"
            + " <span >• Send your INTENT to the pool</span></br>"
            + " <span>• HEDGERs see your INTENT</span></br>"
            + " <span>• A HEDGER accepts your INTENT</span></br>"
            + " <span class=active-span>• INTENTs make up the trade</span>",
          selector: ".section.seven"
        },
        {
          titleSYMM: "",
          list_top: "",
          title: /*"Neutral Parties as WATCHDOGS"*/"",
          subtitle:/*"Liquidators make sure that all PartyA and PartyB pairs are playing by the rules, and are constantly ensuring their solvency. Otherwise they will get liquidated, which makes the system trustless as well as capital efficient."*/"",
          list_top: "<span class= head-span>Neutral Parties as WATCHDOGS</span> "
            + "</br></br>"

            + " <span class=active-span>Liquidators make sure that all PartyA and PartyB pairs are playing by the rules, and are constantly ensuring their solvency. Otherwise they will get liquidated, which makes the system trustless as well as capital efficient.</span></br>",
          selector: ".section.eight"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>PartyA and PartyB are SYMMETRICAL</span> "
            + "</br></br>"

            + " <span class=active-span>exact mirrors of the same position.</span></br>"
            + " <span class=active-span>one Side LONGs 1 BTC,</span></br>"
            + " <span class=active-span>other side SHORTs 1 BTC,</span></br>"
            + " <span class=active-span>no PartyA & B pair = no trade.</span></br>"
            + " <span class=active-span>Loss of A = Win of B,</span></br>"
            + " <span class=active-span>SYMMETRICAL TRADING.</span>",
          selector: ".section.nine"
        },
        {
          titleSYMM: "",
          title: "",
          subtitle: "",
          list_top: "<span class= head-span>INTENT to know more?</span> ",
          selector: ".section.ten"
        }
        // ... (add more content sections as needed)
      ];

      content.forEach((item, i, arr) => {
        const onUpdate = function () {
          const time = this.time();
          const duration = this.duration();

          if (time >= duration || time <= 0) {
            return;
          }
        };

        const timeline = new gsap.timeline({
          scrollTrigger: {
            trigger: item.selector,
            scrub: true,
            start: "top 75%",
            end: `bottom ${i < arr.length - 1 ? "75%" : "bottom"}`
          }
        })
          .to(
            `${item.selector} .title`,
            { text: `${item.title}`, ease: "linear", duration: 0.125, onUpdate },
            0
          )
          .to(
            `${item.selector} .titleSYMM`,
            { text: `${item.titleSYMM}`, ease: "linear", duration: 0.125, onUpdate },
            0
          )
          .to(
            `${item.selector} .subtitle`,
            {
              text: `${item.subtitle}`,
              ease: "linear",
              duration: 0.0625,
              onUpdate
            },
            0
          )
          .to(
            `${item.selector} .list_top`,
            { text: `${item.list_top}`, ease: "linear", duration: 0, onUpdate },
            0
          );

        if (i < arr.length - 1) {
          timeline.yoyo(true).repeat(1).repeatDelay(0.5);
        }
      });
    }
  </script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@300&display=swap');

    html {
      scroll-snap-type: y mandatory;
      overflow: auto;
      overflow-x: hidden;
      scroll-behavior: smooth;

    }


    /*------------------------------------------- Scroll bar */
    html::-webkit-scrollbar {
      width: 2px;
      padding-right: 10px;
      /* Adjust as needed */
    }

    /* Style the track (optional) */
    html::-webkit-scrollbar-track {
      background-color: rgb(44, 32, 32);
    }

    /* Style the thumb (optional) */
    html::-webkit-scrollbar-thumb {
      background-color: rgb(255, 68, 68);
    }


    /*-------------------------------------------  */

    html .section {
      scroll-snap-align: start;
      height: 100vh;
      width: 100%;
      position: relative;
    }


    canvas {
      font-family: "Manrope", sans-serif;
      display: block;
      position: fixed !important;
    }

    /*-------------------------------------------  */

    .box__text {
      font-family: 'Manrope', sans-serif;
      text-align: center;
      top: 0vh;
      margin-bottom: 5vh;
      color: white !important;
      position: fixed;
      width: 100%;

      z-index: 2;
      display: flex;
      flex-direction: column;

    }


    .box__text .subtitle {
      padding-top: 22vh;
      padding-right: 10vh;
      padding-left: 10vh;
      font-size: 1.5vw;
      align-self: center;
      text-align: center;
      /* Add this line */
      text-shadow: 5px 5px 8px #000000;
    }


    .box__text .titleSYMM {
      width: 100%;
      letter-spacing: 7vw;
      position: fixed;
      text-align: center;
      font-size: 8vw;
      margin-left: 4vw;
      bottom: 0.1vh;
    }

    .box__text .list_top {
      font-size: 2vh;
      position: fixed;
      left: 10%;
      top: 20%;
      width: 40%;
      color: gray;
      text-align: left;

    }

    .box__text .list_top .head-span {

      font-size: 4vh;
      letter-spacing: 0;
      -webkit-text-fill-color: transparent;
      background-image: linear-gradient(to right, #fff, #ff8383) !important;
      background-clip: text;
      -webkit-background-clip: text;
      margin-top: 0;
      font-weight: 600;
      line-height: 1.25;
    }

    .box__text .list_top .active-span {

      color: white;
    }



    .gradiant {
      -webkit-text-fill-color: transparent;
      background-image: linear-gradient(to right, #fff, #ff8383) !important;
      background-clip: text;
      -webkit-background-clip: text;

    }


    .caption {
      -webkit-text-fill-color: transparent;
      background-image: linear-gradient(to right, #fff, #ff8383);
      background-clip: text;
      -webkit-background-clip: text;
      width: 80vw;
      line-height: 6vh;
      font-size: 6vh;
      position: relative;
      position: fixed;
      z-index: 99;
      top: 0;
      transform: translateY(-50%);
      padding-top: 32vh;
      padding-left: 20vw;

      transition: opacity 0.1s ease-out, transform 0.5s ease-out;
      /* Add transition for ease-out effect */

    }

    .captionMobile {
      -webkit-text-fill-color: transparent;
      background-image: linear-gradient(to right, #fff, #ff3131);
      background-clip: text;
      -webkit-background-clip: text;
      width: 130vw;
      /* Set width to auto to allow the element to take its content's width */
      line-height: 3vh;
      font-size: 3vh;
      position: fixed;
      z-index: 99;
      left: 78vw;
      /* Set the left position to 50% */
      transform: translateX(-70vw);
      /* Use transform to horizontally center the element */
      padding-top: 23vh;
      transition: opacity 0.1s ease-out, transform 0.5s ease-out;
      /* Add transition for ease-out effect */
      visibility: hidden;
    }

    .captionMobile .first-line {
      margin-left: 20vw;
    }

    .text-box {
      -webkit-text-fill-color: rgb(255, 171, 171) !important;
      display: inline-block;
      position: relative;
    }

    .text-box div {
      display: inline-block;
      position: absolute;
      transform: rotateX(-90deg);
      opacity: 0;
      animation-timing-function: ease;
    }

    .text-box div:nth-child(1) {
      animation: rollDown 20s forwards infinite;
    }

    .text-box div:nth-child(2) {
      animation: rollDown2 20s forwards infinite;
    }

    .text-box div:nth-child(3) {
      animation: rollDown3 20s forwards infinite;
    }

    .text-box div:nth-child(4) {
      animation: rollDown4 20s forwards infinite;
    }

    .text-box div:nth-child(5) {
      animation: rollDown5 20s forwards infinite;
    }

    .text-box div:nth-child(6) {
      animation: rollDown6 20s forwards infinite;
    }

    .text-box div:nth-child(7) {
      animation: rollDown7 20s forwards infinite;
    }

    .text-box div:nth-child(8) {
      animation: rollDown8 20s forwards infinite;
    }

    .text-box div:nth-child(9) {
      animation: rollDown9 20s forwards infinite;
    }

    .text-box div:nth-child(10) {
      animation: rollDown10 20s forwards infinite;
    }


    @keyframes rollDown {
      0% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      1% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      8% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      9% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown2 {
      9% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      10% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      18% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      19% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown3 {
      19% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      20% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      28% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      29% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown4 {
      29% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      30% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      38% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      39% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown5 {
      39% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      40% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      48% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      49% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown6 {
      49% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      50% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      58% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      59% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown7 {
      59% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      60% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      68% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      69% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown8 {
      70% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      71% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      78% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      79% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown9 {
      80% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      81% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      88% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      89% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }

    @keyframes rollDown10 {
      89% {
        top: -16vh;
        transform: rotateX(-90deg);
      }

      90% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      98% {
        top: -5.5vh;
        transform: rotateX(0deg);
        opacity: 1;
      }

      99% {
        top: 16vh;
        transform: rotateX(30deg);
        opacity: 0;
      }
    }






    .scrollDown {
      position: absolute;
      position: fixed;
      z-index: 99;
      right: 3.0vw;
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      /* Add transition for ease-out effect */
      text-decoration: none;
      bottom: 4.5vh;
    }





    .chevron {
      position: absolute;
      width: 4vw;
      height: 0.4vh;
      opacity: 0;
      animation: move 3s ease-out infinite;
    }

    .chevron:first-child {
      animation: move 3s ease-out 1s infinite;
    }

    .chevron:nth-child(2) {
      animation: move 3s ease-out 2s infinite;
    }

    .chevron:before,
    .chevron:after {
      content: ' ';
      position: absolute;
      height: 100%;
      width: 51%;
      background: #fff;
    }

    .chevron:before {
      left: 0;
      transform: skew(0deg, 30deg);
    }

    .chevron:after {
      right: 0;
      width: 50%;
      transform: skew(0deg, -30deg);
    }

    @keyframes move {
      25% {
        opacity: 1;

      }

      33% {
        opacity: 1;
        transform: translateY(1vh);
      }

      67% {
        opacity: 1;
        transform: translateY(2vh);
      }

      100% {
        opacity: 0;
        transform: translateY(3vh);
      }
    }

    .text {
      display: block;
      margin-top: 5vh;
      font-size: 1vw;
      color: #fff;
      text-transform: uppercase;
      white-space: nowrap;
      opacity: .25;
      animation: pulse 2s linear alternate infinite;
      text-decoration: none;
      /* Remove underline */

    }

    @keyframes pulse {
      to {
        opacity: 1;
      }
    }








    /*------------------------- small screens */

    @media screen and (max-width: 900px) {

      .box__text .titleSYMM {
        width: 100%;
        letter-spacing: 5vw;
        position: fixed;
        text-align: center;
        font-size: 16vw;
        margin-left: 2vw;
        top: 8.5vh;
      }

      .box__text .subtitle {
        padding-top: 32vh;
        padding-right: 2vw;
        padding-left: 2vw;
        font-size: 3.5vw;
        align-self: center;
        text-align: center;
        /* Add this line */
        text-shadow: 5px 5px 8px #000000;
      }

      .scrollDown {
        position: absolute;
        position: fixed;
        z-index: 99;
        transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        /* Add transition for ease-out effect */
        text-decoration: none;
        /* Remove underline */
        bottom: 0.0vh;
        right: 0.0vw;

      }

      .chevron {
        position: absolute;
        width: 20vw;
        height: 0.4vh;
        opacity: 0;
        animation: move 3s ease-out infinite;
      }

      .text {
        margin-right: 56vw;
        visibility: hidden;
      }

      .caption {
        visibility: hidden;
      }

      .captionMobile {
        visibility: visible;
      }


      @keyframes rollDown {
        0% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        1% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        8% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        9% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown2 {
        9% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        10% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        18% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        19% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown3 {
        19% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        20% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        28% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        29% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown4 {
        29% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        30% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        38% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        39% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown5 {
        39% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        40% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        48% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        49% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown6 {
        49% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        50% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        58% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        59% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown7 {
        59% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        60% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        68% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        69% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown8 {
        70% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        71% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        78% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        79% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown9 {
        80% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        81% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        88% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        89% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }

      @keyframes rollDown10 {
        89% {
          top: -16vh;
          transform: rotateX(-90deg);
        }

        90% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        98% {
          top: -2.6vh;
          transform: rotateX(0deg);
          opacity: 1;
        }

        99% {
          top: 16vh;
          transform: rotateX(30deg);
          opacity: 0;
        }
      }




      .box__text .list_top {
        font-size: 2vh;
        position: fixed;
        left: 10%;
        top: 10%;
        width: 80%;
        color: gray;
        text-align: left;

      }

      .box__text .list_top .head-span {

        font-size: 4vh;
        letter-spacing: 0;
        -webkit-text-fill-color: transparent;
        background-image: linear-gradient(to right, #fff, #ff8383) !important;
        background-clip: text;
        -webkit-background-clip: text;
        margin-top: 0;
        font-weight: 600;
        line-height: 1.25;
      }
    }
  </style>
  <style>
    .red {
      -webkit-text-fill-color: rgb(255, 94, 94) !important;
    }


    /* Variables */
    :root {
      --white: #FFFFFF;
      --red: #FF4444;
      --blue: #FFAAAA;
    }



    /* Global styles */
    *,
    *:before,
    *:after {
      box-sizing: border-box;
    }

    /* Menu styles */
    .menu__list {
      position: fixed;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 2vh;
      margin-right: 2vh;
      padding: 0;
      list-style: none;
      z-index: 100;
      right: 0;
      /* Add this line to position it to the right */
    }



    .menu__item {
      display: block;
      margin: 1em 0;
      margin: 0 .5em;
    }


    /* Link and Reset button styles */
    nav[role="custom-dropdown"] ul>li>a,
    .menu__link,
    .reset {
      font-family: "Manrope", sans-serif;
      font-weight: 300;
      font-size: 1vw;
      display: block;
      padding: .4em 1em;
      cursor: pointer;
      user-select: none;
      -webkit-touch-callout: none;
      -khtml-user-select: none;
      -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
      position: relative;
      text-align: center;
      color: var(--white);
      background: none;
      border: none;
      text-decoration: none;
      text-transform: uppercase;
      transition: color 0.3s;
    }


    .menu__link:hover,
    .menu__link:focus,
    .reset:hover,
    .reset:focus,
    nav[role="custom-dropdown"] ul>li:hover {
      outline: none;
      color: var(--red);
    }

    /* Remove color change on :active state */
    .menu__link:active {
      color: inherit;
      /* Use the default text color */
    }

    .menu__item--current .menu__link {
      color: var(--blue);
    }

    .menu__item--current .menu__link:before,
    .menu__item--current .menu__link:after {
      opacity: 1;
      transform: translate3d(0, 0, 0);
    }


    .menu__link:before,
    .menu__link:after {
      content: '';
      position: absolute;
      width: 10px;
      height: 10px;
      opacity: 0;
      border: 2px solid var(--red);
      transition: transform 0.3s, opacity 0.3s;
      transition-timing-function: cubic-bezier(0.17, 0.67, 0.05, 1.29);
    }

    .menu__link.active-span {
      position: absolute;
      width: 10px;
      height: 10px;
      opacity: 0;
      border: 2px solid var(--red);
      transition: transform 0.3s, opacity 0.3s;
      transition-timing-function: cubic-bezier(0.17, 0.67, 0.05, 1.29);
    }


    .menu__link:before {
      top: 0;
      left: 0;
      border-width: 2px 0 0 2px;
      transform: translate3d(10px, 10px, 0);
    }

    .menu__link:after {
      right: 0;
      bottom: 0;
      border-width: 0 2px 2px 0;
      transform: translate3d(-10px, -10px, 0);
    }

    /* Reset button styles */
    .reset {
      border: solid 2px var(--red);
      border-radius: 6px;
      margin: 0 auto;
    }











    /*------------------------- custom-dropdown */

    /* Variables */
    :root {
      --number-of-links: 5;
      --hamburger-menu-width: 1.5vw;
      --hamburger-menu-height: 4vh;
      --hamburger-menu-x-position: 60px;
      --hamburger-menu-y-position: 20px;
      --hamburger-icon-background-color: #ffffff;
      --hamburger-icon-width: 10vw;
      --hamburger-icon-height: 2px;
      --hamburger-icon-rotate-deg: 45deg;
      --hamburger-icon-transform-time: 350ms;
      --overlay-background-color: rgba(0, 0, 0, 0.5);
      --menu-link-default-color: #e2e2e2;
      --menu-link-hover-color: #ffffff;
      --menu-link-emboss-color: rgba(0, 0, 0, 0.8);
      --menu-link-shine-color: #ffffff;
      --menu-link-font-size: 3em;
      --menu-link-spacing: 25px;
      --menu-link-shine-size: 25px;
      --menu-link-hover-transition-time: 175ms;
      --menu-link-hover-transition-time-scale: 275ms;
      --menu-link-show-transition-time: 350ms;
    }


    /* .menu-trigger */
    .menu-trigger {
      display: none;
    }

    /* .overlay */
    .overlay {
      width: 0;
      height: 0;
      position: fixed;
      z-index: 200;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .menu-trigger:checked+.overlay {
      background-color: #00000010;
      width: 100%;
      height: 100%;
      -webkit-backdrop-filter: blur(25px);
      backdrop-filter: blur(5px);
      transition: none;
    }


    /* .menu-links */
    .menu-links {
      font-size: var(--menu-link-font-size);
      list-style-type: none;
    }

    .menu-links li {
      text-align: center;
      margin: var(--menu-link-spacing) 0;
    }

    .menu-links li a {
      font-family: "Manrope", sans-serif;
      font-weight: 300;
      font-size: 8vw;
      color: var(--menu-link-default-color);
      display: block;
      text-decoration: none;
      text-shadow: 0 -1px var(--menu-link-emboss-color), 0 0 0 var(--menu-link-shine-color);
      opacity: 0;
      transform: translateX(-25%);
      transition: color var(--menu-link-hover-transition-time) ease-out, text-shadow var(--menu-link-hover-transition-time) ease-out, opacity var(--menu-link-hover-transition-time) ease-out, transform var(--menu-link-hover-transition-time-scale) cubic-bezier(0.18, 0.89, 0.32, 1.28);
    }

    .menu-links li:hover {
      transform: scale(1.2);
    }

    .menu-links li:hover a {
      color: var(--menu-link-hover-color);
      text-shadow: 0 -1px var(--menu-link-emboss-color), 0 0 var(--menu-link-shine-size) var(--menu-link-shine-color);
    }

    .menu-trigger:checked+.overlay .menu-links li a {
      transform: translateX(0);
      opacity: 1;
      transition: opacity var(--menu-link-show-transition-time) ease-out, transform var(--menu-link-show-transition-time) ease-out var(--overlay-animation-timing) calc(0.5 * (var(--menu-link-show-transition-time) / var(--number-of-links)));
    }



    /* .hamburger-menu */
    .hamburger-menu {
      width: var(--hamburger-menu-width);
      height: var(--hamburger-menu-height);
      position: fixed;
      z-index: 999;
      top: var(--hamburger-menu-y-position);
      right: var(--hamburger-menu-x-position);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      cursor: pointer;
      visibility: hidden;

    }

    .hamburger-menu span {
      background-color: var(--hamburger-icon-background-color);
      width: var(--hamburger-icon-width);
      height: var(--hamburger-icon-height);
      flex-grow: 0;
      display: block;
      transition: transform var(--hamburger-icon-transform-time) ease-out;
      transform-origin: center;
    }

    .menu-trigger:checked~.hamburger-menu span:nth-child(1) {
      transform: translateY(calc((var(--hamburger-menu-height) / 2) - (var(--hamburger-icon-height) / 2))) rotate(var(--hamburger-icon-rotate-deg));
    }

    .menu-trigger:checked~.hamburger-menu span:nth-child(2) {
      transform: scale(1, 0) translateX(-100%);
    }

    .menu-trigger:checked~.hamburger-menu span:nth-child(3) {
      transform: translateY(calc(-1 * (var(--hamburger-menu-height) / 2) + (var(--hamburger-icon-height) / 2))) rotate(calc(-1 * var(--hamburger-icon-rotate-deg)));
    }


    /* -------------------------------------------------------------small screens */
    @media screen and (max-width: 900px) {

      /* Menu styles */
      .menu__list {
        visibility: hidden;
      }

      .hamburger-menu {
        visibility: visible;
      }
    }
  </style>
  <nav>
    <ul class="menu__list">
      <li class="menu__item">
        <button class="menu__link" href="#Home">Home</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#HowItWorks">How it works</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#reachus">learn more</button>
      </li>
      <li><button class="reset">Trade</button>
      </li>
    </ul>
  </nav>


</header>

<body>

  <div id="webgl-container"></div>

  <input type="checkbox" id="menu_trigger" class="menu-trigger">
  <div class="overlay">
    <ul class="menu-links">
      <li><a id="link" href="#Home">Home</a></li>
      <li><a id="link" href="#HowItWorks">How it works</a></li>
      <li><a id="link" href="#reachus">learn more</a></li>
      <li><a id="link" class="red" href="#">TRADE</a></li>
    </ul>
  </div>
  <label for="menu_trigger" class="hamburger-menu">
    <span></span>
    <span></span>
    <span></span>
  </label>

  <script>
    // --------------Hambergur menu script
    const menuTrigger = document.querySelector('.menu-trigger');
    const overlay = document.querySelector('.overlay');

    // Get references to all menu links
    const menuLinks = document.querySelectorAll('.menu-links li a');

    // Add a click event listener to each menu link
    menuLinks.forEach(link => {
      link.addEventListener('click', () => {
        // Hide the overlay
        if (menuTrigger.checked = true) {
          menuTrigger.checked = false;
        }
      });
    });
  </script>

  <div class="section one " id="Home">
    <a class="scrollDown">
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="text">[ more ]</span>
    </a>

    <div class="caption ">
      A protocol for SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>
    <div class="captionMobile ">
      <span class="first-line">A protocol for</span><br>
      SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>

    <div class="box__text">

      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section two" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section three" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section four" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="subtitle"></div>
      <div class="title"></div>
    </div>
  </div>

  <div class="section five" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section six" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section seven" id="HowItWorks">
    <div class="box__text">
      <div class="title"></div>
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>

    </div>
  </div>

  <div class="section eight" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section nine" id="HowItWorks">
    <div class="box__text">
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section ten" id="reachus">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
    </div>
  </div>

</body>

</html>


<script id="fragmentShader" type="x-shader/x-fragment">


// ---------------------------------------------------- Settings
precision lowp float; // Reduce precision further if needed

#extension GL_OES_standard_derivatives : enable


uniform vec2 iResolution;
uniform float iTime;
uniform vec2 iMousePos;
vec2 mousePos = (iMousePos / iResolution.xy - .5) * 0.3;
uniform float iScrollProgress;
uniform vec3 iAnimProgress_1;
uniform vec3 iAnimProgress_2;
uniform vec3 iAnimProgress_3;

const ivec2 char_space = ivec2(0, 0);
const ivec2 char_exclam = ivec2(-2147352576, 135274560);
const ivec2 char_quotedbl = ivec2(0, 338186240);
const ivec2 char_numbersign = ivec2(-494600192, 338229411);
const ivec2 char_dollar = ivec2(-2058944512, 475277538);
const ivec2 char_percent = ivec2(1179385856, 105660480);
const ivec2 char_ampersand = ivec2(-1572143104, 68429858);
const ivec2 char_quoteright = ivec2(0, 135270400);
const ivec2 char_parenleft = ivec2(1090781184, 269488160);
const ivec2 char_parenright = ivec2(16842752, 68173953);
const ivec2 char_asterisk = ivec2(-985530368, 139751489);
const ivec2 char_plus = ivec2(-2130706432, 1057264);
const ivec2 char_comma = ivec2(16908800, 0);
const ivec2 char_hyphen = ivec2(0, 224);
const ivec2 char_period = ivec2(131072, 0);
const ivec2 char_slash = ivec2(1077936128, 4210752);
const ivec2 char_zero = ivec2(578945024, 136874258);
const ivec2 char_one = ivec2(-2130247680, 135798848);
const ivec2 char_two = ivec2(1078951936, 474251456);
const ivec2 char_three = ivec2(71761920, 1044398274);
const ivec2 char_four = ivec2(-503054336, 271601811);
const ivec2 char_five = ivec2(71761920, 1040480514);
const ivec2 char_six = ivec2(608632832, 403179762);
const ivec2 char_seven = ivec2(1082195968, 1044398144);
const ivec2 char_eight = ivec2(608632832, 474253538);
const ivec2 char_nine = ivec2(33751040, 474253794);
const ivec2 char_colon = ivec2(131072, 8192);
const ivec2 char_semicolon = ivec2(16908800, 8192);
const ivec2 char_less = ivec2(1090781184, 269488144);
const ivec2 char_equal = ivec2(-536870912, 63491);
const ivec2 char_greater = ivec2(16842752, 68174081);
const ivec2 char_question = ivec2(-2147352576, 474234944);
const ivec2 char_at = ivec2(-1605959680, 474278227);
const ivec2 char_A = ivec2(-465010688, 136874259);
const ivec2 char_B = ivec2(608665600, 507807986);
const ivec2 char_C = ivec2(608632832, 474220560);
const ivec2 char_D = ivec2(608665600, 507808018);
const ivec2 char_E = ivec2(542081024, 1040451824);
const ivec2 char_F = ivec2(541097984, 1040451824);
const ivec2 char_G = ivec2(609157120, 474220563);
const ivec2 char_H = ivec2(608731136, 574917106);
const ivec2 char_I = ivec2(-2130247680, 470818880);
const ivec2 char_J = ivec2(71761920, 541098242);
const ivec2 char_K = ivec2(-1572306944, 572794928);
const ivec2 char_L = ivec2(542081024, 33818640);
const ivec2 char_M = ivec2(608731136, 577546578);
const ivec2 char_N = ivec2(608731136, 574921043);
const ivec2 char_O = ivec2(608632832, 474253586);
const ivec2 char_P = ivec2(541097984, 507807984);
const ivec2 char_Q = ivec2(-1572143104, 474253586);
const ivec2 char_R = ivec2(-1572306944, 507807984);
const ivec2 char_S = ivec2(71761920, 474220770);
const ivec2 char_T = ivec2(-2130575360, 1041244224);
const ivec2 char_U = ivec2(608632832, 574916882);
const ivec2 char_V = ivec2(1090650112, 574916769);
const ivec2 char_W = ivec2(-1522204672, 574916946);
const ivec2 char_X = ivec2(1145602048, 574902337);
const ivec2 char_Y = ivec2(-2130575360, 574902336);
const ivec2 char_Z = ivec2(1078951936, 1044398144);
const ivec2 char_bracketleft = ivec2(1083113472, 1007161376);
const ivec2 char_backslash = ivec2(67108864, 266305);
const ivec2 char_bracketright = ivec2(34045952, 505430145);
const ivec2 char_asciicircum = ivec2(0, 136873984);
const ivec2 char_underscore = ivec2(1015808, 0);
const ivec2 char_quotereversed = ivec2(0, 135282688);
const ivec2 char_a = ivec2(-1001455616, 28931);
const ivec2 char_b = ivec2(608665600, 33847570);
const ivec2 char_c = ivec2(542048256, 61456);
const ivec2 char_d = ivec2(609157120, 541126930);
const ivec2 char_e = ivec2(-532217856, 28947);
const ivec2 char_f = ivec2(-2130575360, 269492448);
const ivec2 char_g = ivec2(609161244, 61714);
const ivec2 char_h = ivec2(608731136, 33847570);
const ivec2 char_i = ivec2(-2130247680, 134230080);
const ivec2 char_j = ivec2(-2130574332, 134225984);
const ivec2 char_k = ivec2(-1031208960, 67670176);
const ivec2 char_l = ivec2(-2130247680, 202383424);
const ivec2 char_m = ivec2(-1521844224, 22866);
const ivec2 char_n = ivec2(608731136, 30994);
const ivec2 char_o = ivec2(608632832, 28946);
const ivec2 char_p = ivec2(608665858, 30994);
const ivec2 char_q = ivec2(609161248, 61714);
const ivec2 char_r = ivec2(1082195968, 53344);
const ivec2 char_s = ivec2(-1006141440, 61457);
const ivec2 char_t = ivec2(-2130444288, 135295040);
const ivec2 char_u = ivec2(609157120, 35090);
const ivec2 char_v = ivec2(1115815936, 35089);
const ivec2 char_w = ivec2(-1522204672, 35090);
const ivec2 char_x = ivec2(-2104983552, 34976);
const ivec2 char_y = ivec2(609161244, 35090);
const ivec2 char_z = ivec2(-2138079232, 63616);
const ivec2 char_braceleft = ivec2(-2129920000, 806363168);
const ivec2 char_brokenbar = ivec2(-2130575360, 135274496);
const ivec2 char_braceright = ivec2(-2130608128, 101720192);
const ivec2 char_asciitilde = ivec2(0, 72630272);
const ivec2 char_filledbox = ivec2(-405831680, 1048377843);
const ivec2 char_sterling = ivec2(1083146240, 407375984);
const ivec2 char_quotesingle = ivec2(0, 135274496);
const ivec2 char_arrowleft = ivec2(1090519040, 1053168);
const ivec2 char_onehalf = ivec2(-1543240648, 33818641);
const ivec2 char_arrowright = ivec2(16777216, 1065457);
const ivec2 char_arrowup = ivec2(-2130706432, 1077584);
const ivec2 char_emdash = ivec2(0, 496);
const ivec2 char_onequarter = ivec2(1175067680, 67637282);
const ivec2 char_dblverticalbar = ivec2(1116012544, 338186401);
const ivec2 char_threequarters = ivec2(1711938592, 101718082);
const ivec2 char_divide = ivec2(16777216, 1049072);
const ivec2 char_comma_saa5051 = ivec2(8454400, 0);
const ivec2 char_period_saa5051 = ivec2(25362432, 0);
const ivec2 char_colon_saa5051 = ivec2(65536, 32);
const ivec2 char_semicolon_saa5051 = ivec2(8454400, 4096);
const ivec2 char_section = ivec2(596119836, 474220770);
const ivec2 char_Adieresis = ivec2(-465010688, 335573267);
const ivec2 char_Odieresis = ivec2(608632832, 335573266);
const ivec2 char_Udieresis = ivec2(608632832, 335579410);
const ivec2 char_degree = ivec2(0, 407396352);
const ivec2 char_adieresis = ivec2(-1001455616, 335573251);
const ivec2 char_odieresis = ivec2(608632832, 2621666);
const ivec2 char_udieresis = ivec2(609157120, 2621714);
const ivec2 char_germandbls = ivec2(608600322, 203704530);
const ivec2 char_currency = ivec2(1133019136, 35041);
const ivec2 char_Eacute = ivec2(-531660800, 269547537);
const ivec2 char_D_saa5052 = ivec2(1149698048, 474517794);
const ivec2 char_L_saa5052 = ivec2(1083113472, 67637280);
const ivec2 char_Aring = ivec2(-465010688, 134246675);
const ivec2 char_eacute = ivec2(-532217856, 269512979);
const ivec2 char_aring = ivec2(-1001455616, 134246659);
const ivec2 char_ccedilla = ivec2(542050312, 61456);
const ivec2 char_ugrave = ivec2(609157120, 68192530);
const ivec2 char_agrave = ivec2(-1001455616, 68186371);
const ivec2 char_ograve = ivec2(608632832, 68157666);
const ivec2 char_egrave = ivec2(-532217856, 68186387);
const ivec2 char_igrave = ivec2(-2130247680, 68157536);
const ivec2 char_idieresis = ivec2(-2130247680, 335556672);
const ivec2 char_edieresis = ivec2(-532217856, 335573267);
const ivec2 char_ecircumflex = ivec2(-532217856, 136868115);
const ivec2 char_ugrave_saa5054 = ivec2(609157120, 136349970);
const ivec2 char_icircumflex = ivec2(-2130247680, 136839264);
const ivec2 char_acircumflex = ivec2(-1001455616, 136868099);
const ivec2 char_ocircumflex_saa5054 = ivec2(608632832, 136868114);
const ivec2 char_ucircumflex = ivec2(609157120, 136839442);
const ivec2 char_ccedilla_saa5054 = ivec2(542050328, 61456);


float draw_char(vec2 coord, ivec2 char) {

    int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;

    int num = pos_id < 32 ? char.x : char.y;
    int val;

    if (pos_id < 32) {
        val = int(mod(float(num) / pow(2.0, float(pos_id)), 2.0));
    } else {
        // Handle the case where pos_id is greater than or equal to 32
        // by using a different bit manipulation technique.
        int shifted_pos_id = pos_id - 32;
        int pow_val = int(pow(2.0, float(shifted_pos_id)));
        val = (num / pow_val);
        val = val - (val / 2) * 2; // Use arithmetic to ensure val is 0 or 1
    }


    float col = val == 0 ? 0.0 : 1.0;

    return col;
}

// --------------------------------------------- Draw words



vec3 draw_text_pool(vec2 p, ivec2 text_box, vec4 text_coord) {
    // Normalized pixel coordinates (from 0 to 1)
    vec2 coord = p;
    coord.x = -coord.x;
    coord /= text_coord.x;
    coord.x += text_coord.y;
    coord.y += text_coord.z;

    // Check if the character is outside the visible area
    if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
        return vec3(0.0); // Return transparent color for characters outside the screen
    }

    coord.x *= float(text_box.x);
    coord.y *= float(text_box.y);
    int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
    coord.x -= float(int(coord.x));
    coord.y -= float(int(coord.y));

    ivec2 text_string_2[13];
    text_string_2[1] = ivec2(char_I);
    text_string_2[2] = ivec2(char_N);
    text_string_2[3] = ivec2(char_T);
    text_string_2[4] = ivec2(char_E);
    text_string_2[5] = ivec2(char_N);
    text_string_2[6] = ivec2(char_T);
    text_string_2[7] = ivec2(char_space);
    text_string_2[8] = ivec2(char_P);
    text_string_2[9] = ivec2(char_O);
    text_string_2[10] = ivec2(char_O);
    text_string_2[11] = ivec2(char_L);


    ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
    if (charIndex == 1) current_char = text_string_2[1];
    else if (charIndex == 2) current_char = text_string_2[2];
    else if (charIndex == 3) current_char = text_string_2[3];
    else if (charIndex == 4) current_char = text_string_2[4];
    else if (charIndex == 5) current_char = text_string_2[5];
    else if (charIndex == 6) current_char = text_string_2[6];
    else if (charIndex == 7) current_char = text_string_2[7];
    else if (charIndex == 8) current_char = text_string_2[8];
    else if (charIndex == 9) current_char = text_string_2[9];
    else if (charIndex == 10) current_char = text_string_2[10];
    else if (charIndex == 11) current_char = text_string_2[11];

    vec3 col = vec3(draw_char(coord, current_char));
    
    return col;
}





vec3 draw_text_you(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
    if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
        return vec3(0.0); // Return transparent color for characters outside the screen
    }

    coord.x *= float(text_box.x);
    coord.y *= float(text_box.y);
    int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
    coord.x -= float(int(coord.x));
    coord.y -= float(int(coord.y));

    ivec2 text_string_2[4];
    text_string_2[1] = ivec2(char_Y);
    text_string_2[2] = ivec2(char_O);
    text_string_2[3] = ivec2(char_U);

    ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
    if (charIndex == 1) current_char = text_string_2[1];
    else if (charIndex == 2) current_char = text_string_2[2];
    else if (charIndex == 3) current_char = text_string_2[3];
    vec3 col = vec3(draw_char(coord, current_char));
    

    return col;
}





vec3 draw_text_hedger(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
    if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
        return vec3(0.0); // Return transparent color for characters outside the screen
    }

    coord.x *= float(text_box.x);
    coord.y *= float(text_box.y);
    int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
    coord.x -= float(int(coord.x));
    coord.y -= float(int(coord.y));

    ivec2 text_string_2[7];
    text_string_2[1] = ivec2(char_H);
    text_string_2[2] = ivec2(char_E);
    text_string_2[3] = ivec2(char_D);
    text_string_2[4] = ivec2(char_G);
    text_string_2[5] = ivec2(char_E);
    text_string_2[6] = ivec2(char_R);

    ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
    if (charIndex == 1) current_char = text_string_2[1];
    else if (charIndex == 2) current_char = text_string_2[2];
    else if (charIndex == 3) current_char = text_string_2[3];
    else if (charIndex == 4) current_char = text_string_2[4];
    else if (charIndex == 5) current_char = text_string_2[5];
    else if (charIndex == 6) current_char = text_string_2[6];
    vec3 col = vec3(draw_char(coord, current_char));
    

    return col;
}






vec3 draw_text_party_a(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
    if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
        return vec3(0.0); // Return transparent color for characters outside the screen
    }

    coord.x *= float(text_box.x);
    coord.y *= float(text_box.y);
    int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
    coord.x -= float(int(coord.x));
    coord.y -= float(int(coord.y));

    ivec2 text_string_2[8];
    text_string_2[1] = ivec2(char_P);
    text_string_2[2] = ivec2(char_A);
    text_string_2[3] = ivec2(char_R);
    text_string_2[4] = ivec2(char_T);
    text_string_2[5] = ivec2(char_Y);
    text_string_2[6] = ivec2(char_space);
    text_string_2[7] = ivec2(char_A);

    ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
    if (charIndex == 1) current_char = text_string_2[1];
    else if (charIndex == 2) current_char = text_string_2[2];
    else if (charIndex == 3) current_char = text_string_2[3];
    else if (charIndex == 4) current_char = text_string_2[4];
    else if (charIndex == 5) current_char = text_string_2[5];
    else if (charIndex == 6) current_char = text_string_2[6];
    else if (charIndex == 7) current_char = text_string_2[7];

    vec3 col = vec3(draw_char(coord, current_char));
    

    return col;
}





vec3 draw_text_party_b(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
    if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
        return vec3(0.0); // Return transparent color for characters outside the screen
    }

    coord.x *= float(text_box.x);
    coord.y *= float(text_box.y);
    int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
    coord.x -= float(int(coord.x));
    coord.y -= float(int(coord.y));

    ivec2 text_string_2[8];
    text_string_2[1] = ivec2(char_P);
    text_string_2[2] = ivec2(char_A);
    text_string_2[3] = ivec2(char_R);
    text_string_2[4] = ivec2(char_T);
    text_string_2[5] = ivec2(char_Y);
    text_string_2[6] = ivec2(char_space);
    text_string_2[7] = ivec2(char_B);

    ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
    if (charIndex == 1) current_char = text_string_2[1];
    else if (charIndex == 2) current_char = text_string_2[2];
    else if (charIndex == 3) current_char = text_string_2[3];
    else if (charIndex == 4) current_char = text_string_2[4];
    else if (charIndex == 5) current_char = text_string_2[5];
    else if (charIndex == 6) current_char = text_string_2[6];
    else if (charIndex == 7) current_char = text_string_2[7];

    vec3 col = vec3(draw_char(coord, current_char));
    

    return col;
}


vec3 draw_text_intent_a(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
    if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
        return vec3(0.0); // Return transparent color for characters outside the screen
    }

    coord.x *= float(text_box.x);
    coord.y *= float(text_box.y);
    int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
    coord.x -= float(int(coord.x));
    coord.y -= float(int(coord.y));

    ivec2 text_string_2[9];
    text_string_2[1] = ivec2(char_I);
    text_string_2[2] = ivec2(char_N);
    text_string_2[3] = ivec2(char_T);
    text_string_2[4] = ivec2(char_E);
    text_string_2[5] = ivec2(char_N);
    text_string_2[6] = ivec2(char_T);
    text_string_2[7] = ivec2(char_space);
    text_string_2[8] = ivec2(char_A);

    ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
    if (charIndex == 1) current_char = text_string_2[1];
    else if (charIndex == 2) current_char = text_string_2[2];
    else if (charIndex == 3) current_char = text_string_2[3];
    else if (charIndex == 4) current_char = text_string_2[4];
    else if (charIndex == 5) current_char = text_string_2[5];
    else if (charIndex == 6) current_char = text_string_2[6];
    else if (charIndex == 7) current_char = text_string_2[7];
    else if (charIndex == 8) current_char = text_string_2[8];

    vec3 col = vec3(draw_char(coord, current_char));
    

    return col;
}
vec3 draw_text_intent_b(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
    if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
        return vec3(0.0); // Return transparent color for characters outside the screen
    }

    coord.x *= float(text_box.x);
    coord.y *= float(text_box.y);
    int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
    coord.x -= float(int(coord.x));
    coord.y -= float(int(coord.y));

    ivec2 text_string_2[9];
    text_string_2[1] = ivec2(char_I);
    text_string_2[2] = ivec2(char_N);
    text_string_2[3] = ivec2(char_T);
    text_string_2[4] = ivec2(char_E);
    text_string_2[5] = ivec2(char_N);
    text_string_2[6] = ivec2(char_T);
    text_string_2[7] = ivec2(char_space);
    text_string_2[8] = ivec2(char_B);

    ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
    if (charIndex == 1) current_char = text_string_2[1];
    else if (charIndex == 2) current_char = text_string_2[2];
    else if (charIndex == 3) current_char = text_string_2[3];
    else if (charIndex == 4) current_char = text_string_2[4];
    else if (charIndex == 5) current_char = text_string_2[5];
    else if (charIndex == 6) current_char = text_string_2[6];
    else if (charIndex == 7) current_char = text_string_2[7];
    else if (charIndex == 8) current_char = text_string_2[8];

    vec3 col = vec3(draw_char(coord, current_char));
    

    return col;
}





vec3 draw_text_liquidator(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

  // Check if the character is outside the visible area
  if (coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
      return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[11];
  text_string_2[1] = ivec2(char_L);
  text_string_2[2] = ivec2(char_I);
  text_string_2[3] = ivec2(char_Q);
  text_string_2[4] = ivec2(char_U);
  text_string_2[5] = ivec2(char_I);
  text_string_2[6] = ivec2(char_D);
  text_string_2[7] = ivec2(char_A);
  text_string_2[8] = ivec2(char_T);
  text_string_2[9] = ivec2(char_O);
  text_string_2[10] = ivec2(char_R);


  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

  //  using [charIndex]
  if (charIndex == 1) current_char = text_string_2[1];
  else if (charIndex == 2) current_char = text_string_2[2];
  else if (charIndex == 3) current_char = text_string_2[3];
  else if (charIndex == 4) current_char = text_string_2[4];
  else if (charIndex == 5) current_char = text_string_2[5];
  else if (charIndex == 6) current_char = text_string_2[6];
  else if (charIndex == 7) current_char = text_string_2[7];
  else if (charIndex == 8) current_char = text_string_2[8];
  else if (charIndex == 9) current_char = text_string_2[9];
  else if (charIndex == 10) current_char = text_string_2[10];

  vec3 col = vec3(draw_char(coord, current_char));
  
  return col;
}
//-------------------------------------------- Triangles and animation Rendering

const float k = sqrt(3.0);

ivec2 text_box_chars = ivec2(13, 7);
vec4 text_coord; // Scale.xy   Position.zw


vec3 eyeRender(vec3 col, vec2 p, float vis) {
  // Calculate blink
  float eyeBlink = smoothstep(-0.28, 0.2, mod(iTime, 0.0));
  eyeBlink -= smoothstep(0.28, 0.4, mod(iTime, 2.5));
  // REPLACEMENT
  vec2 rotatedP = vec2(-p.y + 0.2, p.x);
  // Calculate Almond Eye
  float bl = 1.0;
  bl *= vis;
  float k = -clamp(bl * bl, 0.06, 1.0);
  vec2 pos = vec2(-4.0 * rotatedP.y, 4.0 * rotatedP.x);
  pos = abs(pos);
  float ik = 1.0 / k;
  float parabola_p = ik * (pos.y - 1.1 * ik) / 3.0;
  float parabola_q = 0.25 * ik * ik * pos.x;
  float parabola_h = parabola_q * parabola_q - parabola_p * parabola_p * parabola_p;
  float parabola_r = sqrt(abs(parabola_h));
  float parabola_x = (parabola_h > 0.0) ? pow(parabola_q + parabola_r, 1.0 / 3.0) - pow(abs(parabola_q - parabola_r), 1.0 / 3.0) * sign(parabola_r - parabola_q) : 2.0 * cos(atan(parabola_r, parabola_q) / 3.0) * sqrt(parabola_p);

  float sdEye = length(pos - vec2(parabola_x, k * parabola_x * parabola_x)) * sign(pos.x - parabola_x) - bl + 0.06;

  // Apply smoothstep to color using sdEye
  col += smoothstep(0.015, 0.025, abs(sdEye));
  // Eye core creation and reposition
  vec2 adjustedMousePos = vec2(-mousePos.y, 1.1 * (mousePos.x - 0.07)) * 2.0;
  vec2 diff = 2.0 * rotatedP - adjustedMousePos;
  float distance = length(diff) - 0.3 - 2.0 * smoothstep(0.895, 0.9, 0.0);
  float eyeMask = max(distance, sdEye);
  col = min(col, smoothstep(-0.01, 0.0, eyeMask * vis));
  return col;
}
vec3 triRender2(vec3 col, vec2 p, vec3 text) {
  vec3 fillColor = vec3(0.005, 0.0, 0.0);

  vec3 glow_col = vec3(0.008, 0.001, 0.001);
  p.x = abs(p.x) - 1.0;
  p.y = p.y + 1.0 / k;
  p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
  p.x -= clamp(p.x, -2.0, 0.0);
  float dt = -length(p) * sign(p.y);
  col = mix((dt < -0.0) ? fillColor : col, col, 0.0);
  col += glow_col / max(abs(dt), 0.001);
  col = mix(col,vec3(1.0,0.4,0.4),text);

return col;
}

vec3 triRender(vec3 col, vec3 ro, vec3 rd, float text_selector, vec2 tri_pos, float tri_scl, float tri_vis, vec3 glow_color) {
    vec3 fillColor = vec3(0.005, 0.0, 0.0);
    const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
    float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
    vec3 pp = ro + rd * tpd;
    vec2 p = pp.xy * 0.5;
    p.y -= 0.58;
    p += tri_pos;
    p *= tri_scl;
    vec2 p_text = p;
    vec3 glow_col = glow_color;
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
    p.x -= clamp(p.x, -2.0, 0.0);
    float dt = -length(p) * sign(p.y);
    col = mix((dt < -0.0) ? fillColor : col, col, 1.0 - tri_vis);
    vec3 tri_col = col;
    col += glow_col / max(abs(dt), 0.001);

    //  YOU
    if (text_selector==1.0){
        text_coord = vec4(1.3, 0.2, 0.95, 0.0); // Scale.x   Position.yz
        col = mix(col,vec3(1.0),draw_text_you(p_text, text_box_chars, text_coord));
    }
    // HEDGER
    else if (text_selector==2.0){
        text_coord = vec4(1.3, 0.3, 0.95, 0.0); // Scale.x   Position.yz
        col = mix(col,vec3(1.0,0.2,0.2),draw_text_hedger(p_text, text_box_chars, text_coord));
    }

    //  INTENT POOL
    else if (text_selector==3.0){
        text_coord = vec4(0.9, 0.48, 0.5, 0.0); // Scale.x   Position.yz
        col = mix(col,vec3(1.0,0.4,0.4),draw_text_pool(p_text, text_box_chars, text_coord));
    }

    //  PARTY A
    else if (text_selector==4.0){
      text_coord = vec4(1.3, 0.34, 0.75, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0),draw_text_party_a(p_text, text_box_chars, text_coord));
    }

    //  PARTY B
    else if (text_selector==5.0){
      text_coord = vec4(1.3, 0.34, 0.75, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0,0.2,0.2),draw_text_party_b(p_text, text_box_chars, text_coord));
    }

    //  INTENT A
    else if (text_selector==6.0){
      text_coord = vec4(1.3, 0.35, 0.75, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0,0.2,0.2),draw_text_intent_a(p_text, text_box_chars, text_coord));
    }

    //  INTENT B
    else if (text_selector==7.0){
      text_coord = vec4(1.3, 0.34, 0.95, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0,0.2,0.2),draw_text_intent_b(p_text, text_box_chars, text_coord));
    }

    //  LIQUIDATOR
    else if (text_selector==8.0){
      text_coord = vec4(1.3, 0.45, 1.0, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0),draw_text_liquidator(p_text, text_box_chars, text_coord)*tri_vis);
      col = mix(glow_color*1000.0, col, eyeRender(col, p_text, 1.0));

    }
    
    // YOU   +    INTENT A
    else if (text_selector==23.0){
      text_coord = vec4(1.3, 0.35, 0.75, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0),draw_text_intent_a(p_text, text_box_chars, text_coord));
      text_coord = vec4(1.3, 0.2, 0.95, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0),draw_text_you(p_text, text_box_chars, text_coord));
  }
    // PARTY A   +    INTENT A
    else if (text_selector==24.0){
      text_coord = vec4(1.3, 0.38-(iAnimProgress_2.z*1.5), 0.75, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0),draw_text_intent_a(p_text, text_box_chars, text_coord));
      text_coord = vec4(1.3, 0.35, 0.95, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0),draw_text_party_a(p_text, text_box_chars, text_coord));
    }

    // PARTY B   +    INTENT B
    else if (text_selector==25.0){
      text_coord = vec4(1.3, 0.38+(iAnimProgress_2.z*1.55), 0.75, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0,0.2,0.2),draw_text_intent_b(p_text, text_box_chars, text_coord));
      text_coord = vec4(1.3, 0.34, 0.95, 0.0); // Scale.x   Position.yz
      col = mix(col,vec3(1.0,0.2,0.2),draw_text_party_b(p_text, text_box_chars, text_coord));
    }
    return col;
}

vec3 glow_color;
float text_selector = 0.0;
vec2 tri_pos;
float tri_scl=1.0;
float tri_vis=1.0;
float tri2_vis=1.0;

vec3 anim_render(vec3 col,vec3 ro, vec3 rd){
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy;

  //Section Animation 1.x
    if (iAnimProgress_1.x>=0.0 && iAnimProgress_1.x <0.5){
        //middle triangle
        tri_vis=1.0;
        tri_scl=1.0;
        glow_color = vec3(0.008, 0.001, 0.001);
        text_selector = 0.0;
        tri_pos=vec2(0.0,0.0);
        col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
    }

//Section Animation 1.y
    else if (iAnimProgress_1.x>=0.5 && iAnimProgress_1.y <0.5){
        //middle triangle
        tri_vis=1.0;
        tri_scl=1.0;
        glow_color = vec3(0.008, 0.001, 0.001);
        text_selector = 3.0; //draw_text_pool
        tri_pos=vec2(0.0,0.0);
        col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
        
        //right triangle
        tri_pos=vec2(0.0+iAnimProgress_1.x,0.29);
        tri_vis=1.0;
        tri_scl=2.0;
        glow_color = vec3(0.01, 0.0005, 0.0005)-iAnimProgress_1.x*vec3(0.008, 0.0004, 0.0004);
        text_selector = 2.0; //draw_text_hedger
        col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

        //left triangle
        tri_pos=vec2(0.0-iAnimProgress_1.x,0.29);
        tri_vis=0.0+iAnimProgress_1.x;
        tri_scl=2.0;
        glow_color = vec3(0.005, 0.005, 0.005)-iAnimProgress_1.x*vec3(0.004);
        text_selector = 1.0; //draw_text_you
        col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

    }
    
//Section Animation 1.z
    else if (iAnimProgress_1.y>=0.5 && iAnimProgress_1.z <0.5){
        //middle triangle
        tri_vis=1.0;
        tri_scl=1.0;
        glow_color = vec3(0.008, 0.001, 0.001);
        text_selector = 3.0; //draw_text_pool
        tri_pos=vec2(0.0,0.0);
        col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
        
        //right triangle
        tri_pos=vec2(0.0+iAnimProgress_1.x,0.29);
        tri_vis=1.0;
        tri_scl=2.0;
        glow_color = vec3(0.01, 0.0005, 0.0005)-iAnimProgress_1.x*vec3(0.008, 0.0004, 0.0004);
        text_selector = 2.0; //draw_text_hedger
        col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

        //left triangle
        tri_pos=vec2(-1.0+(iAnimProgress_1.z*0.5),0.29);
        tri_vis=0.0+iAnimProgress_1.x;
        tri_scl=2.0;
        glow_color = vec3(0.005, 0.005, 0.005);
        text_selector = 23.0; //draw_text_you   +   intent a
        col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
}

//Section Animation 2.x
    else if (iAnimProgress_1.z>=0.5 && iAnimProgress_2.x <0.5){
      //middle triangle
      tri_vis=1.0;
      tri_scl=1.0;
      glow_color = vec3(0.008, 0.001, 0.001);
      text_selector = 3.0; //draw_text_pool
      tri_pos=vec2(0.0,0.0);
      col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
      
      //right triangle
      tri_pos=vec2(0.0+iAnimProgress_1.x,0.29);
      tri_vis=1.0;
      tri_scl=2.0;
      glow_color = vec3(0.01, 0.0005, 0.0005)-iAnimProgress_1.x*vec3(0.008, 0.0004, 0.0004);
      text_selector = 2.0; //draw_text_hedger
      col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

      //left triangle
      tri_pos=vec2(-1.0+(iAnimProgress_1.z*0.5),0.29);
      tri_vis=1.0;
      tri_scl=2.0;
      glow_color = vec3(0.005, 0.005, 0.005);
      text_selector = 24.0; //draw_text_part_a  +   _intent_a
      col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
}  
  //Section Animation 2.y
  else if (iAnimProgress_2.x >= 0.5 && iAnimProgress_2.y < 0.5){
    //middle triangle
    tri_vis=1.0;
    tri_scl=1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 3.0; //draw_text_pool
    tri_pos=vec2(0.0,0.0);
    col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
    
    //right triangle
    tri_pos=vec2(1.0-iAnimProgress_2.y*0.5,0.29);
    tri_vis=1.0;
    tri_scl=2.0;
    glow_color = vec3(0.006, 0.0001, 0.0001);
    text_selector = 2.0; //draw_text_hedger
    col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

    //left triangle
    tri_pos=vec2(-1.0+(iAnimProgress_1.z*0.5),0.29);
    tri_vis=1.0;
    tri_scl=2.0;
    glow_color = vec3(0.005, 0.005, 0.005);
    text_selector = 24.0; //draw_text_part_a  +   _intent_a
    col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
}



  //Section Animation 2.y
else if (iAnimProgress_2.y >= 0.5 && iAnimProgress_2.z < 0.5){
  //middle triangle
  tri_vis=1.0;
  tri_scl=1.0;
  glow_color = vec3(0.008, 0.001, 0.001);
  text_selector = 3.0; //draw_text_pool
  tri_pos=vec2(0.0,0.0);
  col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
  
  //right triangle
  tri_pos=vec2(1.0-iAnimProgress_2.y*0.5,0.29);
  tri_vis=1.0-iAnimProgress_2.z;
  tri_scl=2.0;
  glow_color = vec3(0.006, 0.0001, 0.0001);
  text_selector = 25.0; //draw_text_part_b
  col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

  //left triangle
  tri_pos=vec2(-0.5,0.29);
  tri_vis=1.0;
  tri_scl=2.0;
  glow_color = vec3(0.005, 0.005, 0.005);
  text_selector = 24.0; //draw_text_part_a
  col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
}


//Section Animation 2.z
else if (iAnimProgress_2.z >= 0.5 && iAnimProgress_3.x < 0.5){
  //middle triangle
  tri_vis=1.0;
  tri_scl=1.0;
  glow_color = vec3(0.008, 0.001, 0.001);
  text_selector = 3.0; //draw_text_pool
  tri_pos=vec2(0.0,0.0);
  col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
  
  //right triangle
  tri_pos=vec2(1.0-iAnimProgress_2.y*0.5,0.29);
  tri_vis=0.0;
  tri_scl=2.0;
  glow_color = vec3(0.006, 0.0001, 0.0001)*(1.0-iAnimProgress_3.x);
  text_selector = 25.0; //draw_text_part_b
  col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

  //left triangle
  tri_pos=vec2(-1.0+(iAnimProgress_1.z*0.5),0.29);
  tri_vis=0.0-iAnimProgress_2.y;
  tri_scl=2.0;
  glow_color = vec3(0.005, 0.005, 0.005)*(1.0-iAnimProgress_3.x);
  text_selector = 24.0; //draw_text_part_a
  col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);
} 


//Section Animation 3.x
else if (iAnimProgress_3.x >= 0.5 && iAnimProgress_3.y < 0.5){
  //middle triangle
  tri_vis=1.0;
  tri_scl=1.0;
  glow_color = vec3(0.008, 0.001, 0.001);
  text_selector = 0.0; //draw_text_pool
  tri_pos=vec2(0.0,0.0);
  col = triRender(col, ro, rd, text_selector,tri_pos,tri_scl,tri_vis,glow_color);

  //Liquidator triangle
  tri_pos=vec2(0.0+sin(iTime),-1.57+cos(iTime));
  tri_vis=1.0;
  tri_scl=2.0;
  glow_color = vec3(0.005, 0.005, 0.005);
  text_selector = 8.0; //draw_text_part_a
  vec2 anim = vec2(cos(iTime+0.0),sin(iTime+0.0));
  vec2 anim2 = vec2(cos(iTime+3.14),sin(iTime+3.14));

  //---------------------Tri 1 Animation
  //   Quadrant I
  if ((anim.x > 0.0 && anim.y < 0.0)){
    tri_vis=1.0*anim.x;
    glow_color = vec3(0.005, 0.005, 0.005)*anim.x;
    col = triRender(col, ro, rd, text_selector,vec2(anim.x,anim.y-1.57),tri_scl,tri_vis,glow_color);
    }
  
    //   Quadrant II
    else if ((anim.x < 0.0 && anim.y < 0.0)){
  
    }
      //   Quadrant III
    else if ((anim.x < 0.0 && anim.y > 0.0)){
      glow_color = vec3(0.005, 0.005, 0.005)*(sin(iTime));
      tri_vis=1.0*(sin(iTime));
      anim.x = 0.0;
      anim.y = 1.0;
      col = triRender(col, ro, rd, text_selector,vec2(anim.x,anim.y-1.57),tri_scl,tri_vis,glow_color);
    }
  
    //   Quadrant IV
    else if ((anim.x > 0.0 && anim.y > 0.0)){
    col = triRender(col, ro, rd, text_selector,vec2(anim.x,anim.y-1.57),tri_scl,tri_vis,glow_color);
    }
  
  //---------------------Tri 2 Animation
  //Quadrant I
  if ((anim2.x > 0.0 && anim2.y < 0.0)){
  tri_vis=1.0*anim2.x;
  glow_color = vec3(0.005, 0.005, 0.005)*anim2.x;
  col = triRender(col, ro, rd, text_selector,vec2(anim2.x,anim2.y-1.57),tri_scl,tri_vis,glow_color);
    
  //Quadrant II
  }else if ((anim2.x < 0.0 && anim2.y < 0.0)){

  //Quadrant III
  }else if ((anim2.x < 0.0 && anim2.y > 0.0)){
  glow_color = vec3(0.005, 0.005, 0.005)*(sin(iTime+3.14));
  tri_vis=1.0*(sin(iTime+3.14));
  anim2.x = 0.0;
  anim2.y = 1.0;
  col = triRender(col, ro, rd, text_selector,vec2(anim2.x,anim2.y-1.57),tri_scl,tri_vis,glow_color);
  
  //Quadrant IV Tri 2
  }else if ((anim2.x > 0.0 && anim2.y > 0.0)){
  col = triRender(col, ro, rd, text_selector,vec2(anim2.x,anim2.y-1.57),tri_scl,tri_vis,glow_color);

}  


  


} 
  return col;
}





//-------------------------------------------- Sky and ground rendering
vec2 tilesSize = vec2(1.0);
const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));
const vec4 gpdim = vec4(gpn, 0.0);
vec3 sunDir = normalize(vec3(0.0, -2.0, 20.0));
const vec3 sunCol = vec3(0.0015, 0.001, 0.001);

vec3 outerSkyRender(vec3 ro, vec3 rd) {
    vec3 col = vec3(0.1, 0.1, 0.1);
    float sunDot = dot(sunDir, rd);
    if (sunDot > 0.0) {
        col += sunCol / pow(1.002 - sunDot, 1.9-iAnimProgress_1.x);
    }
    vec3 gcol = vec3(0.003-iAnimProgress_1.x*0.0025);
    col +=  gcol / max(abs(rd.y), 0.0001);
    return col;
}

vec3 groundRender(vec3 col, vec3 ro, vec3 rd) {
    float gpd = -(dot(ro, gpdim.xyz) + gpdim.w) / dot(rd, gpdim.xyz);
    if (gpd < 0.0) {
        return col;
    }
    vec3 gp = ro + rd * gpd;
    float gpfre = 1.15 + dot(rd, gpn);
    gpfre *= gpfre * gpfre * gpfre; // Reduce power operations
    vec3 grr = reflect(rd, gpn);
    vec2 ggp = gp.xz;
    ggp.y += iTime;
    float dfy = dFdy(ggp.y);
    float gcf = sin(ggp.x) * sin(ggp.y);
    ggp = mod(ggp + tilesSize * 0.5, tilesSize) - tilesSize * 0.5;
    float ggd = min(abs(ggp.x), abs(ggp.y));
    vec3 glow_col = vec3(0.002, 0.001, 0.001);
    vec3 rcol = outerSkyRender(grr, grr);
    rcol = anim_render(rcol, gp, grr);
    
    col = glow_col / max(ggd, 0.0 + 0.25 * dfy);
    col += rcol * gpfre / 2.0;

    //change the reflection value
    col *= 1.0-(iAnimProgress_1.x*0.7);
    return col;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 q = fragCoord / iResolution.xy;
    vec2 p = -1.0 + 2.0 * q;
    p.x *= iResolution.x / iResolution.y;
    const float fov = 2.0;
    vec3 ro = vec3(0.0, 0.5, -5.0);
    const vec3 la = vec3(0.0, 1.5, 0.0);
    const vec3 up = vec3(0.0, 1.0, 0.0);
    vec3 ww = normalize(la - ro);
    vec3 uu = normalize(cross(up, ww));
    vec3 vv = cross(ww, uu);
    vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);
    vec3 col = outerSkyRender(rd, rd);
    col = groundRender(col, ro, rd);
    col = anim_render(col, ro, rd);
    fragColor = vec4(col, 1.0);
}



void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
</script>

<script>

  // Define global variables
  let container;
  let camera, scene, renderer;
  let uniforms;
  let startTime;
  let scrollProgress;

  // Initialize the scene
  init();
  animate();

  // Initialize the Three.js scene
  function init() {
    // Setup gsap plugins
    gsap.registerPlugin(ScrollTrigger);
    gsap.registerPlugin(TextPlugin);

    container = document.getElementById("webgl-container");
    startTime = Date.now();

    camera = new THREE.OrthographicCamera(
      0,
      window.innerWidth,
      0,
      window.innerHeight,
      1,
      1000
    );

    scene = new THREE.Scene();

    const geometry = new THREE.PlaneBufferGeometry(
      window.innerWidth,
      window.innerHeight
    );

    // Define uniforms
    uniforms = {
      iTime: { type: "f", value: 1.0 },
      iResolution: { type: "v2", value: new THREE.Vector2() },
      iMousePos: { type: "v2", value: new THREE.Vector2() },
      iScrollProgress: { type: "f", value: 0.0 },
      iAnimProgress_1: { type: "v3", value: new THREE.Vector3() },
      iAnimProgress_2: { type: "v3", value: new THREE.Vector3() },
      iAnimProgress_3: { type: "v3", value: new THREE.Vector3() },
      iAnimProgress_4: { type: "v3", value: new THREE.Vector3() },
      iAnimProgress_5: { type: "v3", value: new THREE.Vector3() },
      iAnimProgress_6: { type: "v3", value: new THREE.Vector3() }

    };

    // Create the shader material
    const material = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: `void main() {gl_Position = vec4(position, 1.0);}`,
      fragmentShader: document.getElementById("fragmentShader").textContent
    });

    // Create and add mesh to the scene
    const mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    // Create the renderer
    renderer = new THREE.WebGLRenderer({
      precision: "lowp" // Set precision for smooth gradients and better precision
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Set up content scroll triggers
    setupContentScrollTrigger();

    // Handle window resizing
    handleResize();
    window.addEventListener("resize", handleResize);

    // Update scroll progress on mouse move and scrolling
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("scroll", updateScrollProgress);
  }

  // Animate the scene
  function animate() {
    render();
    requestAnimationFrame(animate);
  }

  // Render the scene
  function render() {
    const currentTime = Date.now();
    uniforms.iTime.value = (currentTime - startTime) * 0.001;
    renderer.render(scene, camera);
  }

  // Handle window resize
  function handleResize() {
    uniforms.iResolution.value.x = window.innerWidth * window.devicePixelRatio;

    uniforms.iResolution.value.y = window.innerHeight * window.devicePixelRatio;
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Update mouse position
  function handleMouseMove(event) {
    uniforms.iMousePos.value.x = event.clientX * window.devicePixelRatio;
    uniforms.iMousePos.value.y =
      (window.innerHeight - event.clientY) * window.devicePixelRatio;
  }

  // Update scroll progress
  // Set up scroll triggers for animations
  function sectionScroller() {
    const sections = [
      ".section.one",
      ".section.two",
      ".section.three",
      ".section.four",
      ".section.five",
      ".section.six",
      ".section.seven",
      ".section.eight",
      ".section.nine",
      ".section.ten",
    ];
    const scrollToSection = (section) => {
      const sectionElement = document.querySelector(section);
      window.scrollTo({ top: sectionElement.getBoundingClientRect().top, behavior: "smooth" });
    };

    sections.forEach((section, index) => {
      gsap.to({}, {
        duration: 2,
        delay: index * 2,
        onComplete: () => {
          if (index <= 6) {
            scrollToSection(sections[index + 1]);
          }
        }
      });
    });
  }


  gsap.to({}, {
    delay: 4,
    duration: 2,
    scrollTrigger: {
      trigger: ".section.four",
      scrub: true,
    }
  });

  gsap.to(uniforms.iAnimProgress_1.value, {
    x: 1,
    scrollTrigger: {
      trigger: ".section.one",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
  gsap.to(uniforms.iAnimProgress_1.value, {
    y: 1,
    scrollTrigger: {
      trigger: ".section.two",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
  gsap.to(uniforms.iAnimProgress_1.value, {
    z: 1,
    scrollTrigger: {
      trigger: ".section.three",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
  gsap.to(uniforms.iAnimProgress_2.value, {
    x: 1,
    scrollTrigger: {
      trigger: ".section.four",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
  gsap.to(uniforms.iAnimProgress_2.value, {
    y: 1,
    scrollTrigger: {
      trigger: ".section.five",
      start: "0%",
      end: "100%",
      scrub: true,
    }
  });
  gsap.to(uniforms.iAnimProgress_2.value, {
    z: 1,
    scrollTrigger: {
      trigger: ".section.six",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });

  gsap.to(uniforms.iAnimProgress_3.value, {
    x: 1,
    scrollTrigger: {
      trigger: ".section.seven",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
  gsap.to(uniforms.iAnimProgress_3.value, {
    y: 1,
    scrollTrigger: {
      trigger: ".section.eight",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
  gsap.to(uniforms.iAnimProgress_3.value, {
    z: 1,
    scrollTrigger: {
      trigger: ".section.nine",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
  gsap.to(uniforms.iAnimProgress_4.value, {
    x: 1,
    scrollTrigger: {
      trigger: ".section.ten",
      start: "0%",
      end: "100%",
      scrub: true
    }
  });
</script>