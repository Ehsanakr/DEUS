<html lang="en">

<header>
  <title>SYMMIO</title>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="./jQuerySet.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
  
  <script src="https://unpkg.com/gsap@3.5.1/dist/ScrollTrigger.min.js"></script>
  <script src="https://unpkg.com/gsap@3.5.1/dist/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.4.0/TextPlugin.min.js"></script>
  <script src="./gsapText.js"></script>

  <link rel="stylesheet" href="styleHome.css">
  <link rel="stylesheet" href="navbar.css">

  <nav>
    <ul class="menu__list">
      <li class="menu__item">
        <button class="menu__link" href="#Home">Home</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#HowItWorks">How it works</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#reachus">learn more</button>
      </li>
      <li><button class="reset">Trade</button>
      </li>
    </ul>
  </nav>


</header>

<body>

  <div id="webgl-container"></div>

  <input type="checkbox" id="menu_trigger" class="menu-trigger">
  <div class="overlay">
    <ul class="menu-links">
      <li><a id="link" href="#Home">Home</a></li>
      <li><a id="link" href="#HowItWorks">How it works</a></li>
      <li><a id="link" href="#reachus">learn more</a></li>
      <li><a id="link" class="red" href="#">TRADE</a></li>
    </ul>
  </div>
  <label for="menu_trigger" class="hamburger-menu">
    <span></span>
    <span></span>
    <span></span>
  </label>

  <script>
    // --------------Hambergur menu script
    const menuTrigger = document.querySelector('.menu-trigger');
    const overlay = document.querySelector('.overlay');

    // Get references to all menu links
    const menuLinks = document.querySelectorAll('.menu-links li a');

    // Add a click event listener to each menu link
    menuLinks.forEach(link => {
      link.addEventListener('click', () => {
        // Hide the overlay
        if (menuTrigger.checked = true) {
          menuTrigger.checked = false;
        }
      });
    });
  </script>

  <div class="section one " id="Home">
    <a class="scrollDown">
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="text">[ more ]</span>
    </a>

    <div class="caption ">
      A protocol for SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>
    <div class="captionMobile ">
      <span class="first-line">A protocol for</span><br>
      SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>

    <div class="box__text">

      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section two" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section three" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section four" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="subtitle"></div>
      <div class="title"></div>
    </div>
  </div>

  <div class="section five" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section six" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section seven" id="HowItWorks">
    <div class="box__text">
      <div class="title"></div>
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>

    </div>
  </div>

  <div class="section eight" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section nine" id="HowItWorks">
    <div class="box__text">
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section ten" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
    </div>
  </div>

  <div class="section eleven" id="reachus">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
    </div>
  </div>

</body>

</html>


<script src="./webGl.glsl" id="fragmentShader" type="x-shader/x-fragment">


// ---------------------------------------------------- Settings
precision lowp float; // Reduce precision further if needed

#extension GL_OES_standard_derivatives : enable

uniform vec2 iResolution;
uniform float iTime;
uniform vec2 iMousePos;
vec2 mousePos = (iMousePos / iResolution.xy - .5) * 0.3;
uniform float iScrollProgress;
uniform vec3 iAnimProgress_1;
uniform vec3 iAnimProgress_2;
uniform vec3 iAnimProgress_3;
uniform vec3 iAnimProgress_4;


const ivec2 char_space = ivec2(0, 0);
const ivec2 char_exclam = ivec2(-2147352576, 135274560);
const ivec2 char_quotedbl = ivec2(0, 338186240);
const ivec2 char_numbersign = ivec2(-494600192, 338229411);
const ivec2 char_dollar = ivec2(-2058944512, 475277538);
const ivec2 char_percent = ivec2(1179385856, 105660480);
const ivec2 char_ampersand = ivec2(-1572143104, 68429858);
const ivec2 char_quoteright = ivec2(0, 135270400);
const ivec2 char_parenleft = ivec2(1090781184, 269488160);
const ivec2 char_parenright = ivec2(16842752, 68173953);
const ivec2 char_asterisk = ivec2(-985530368, 139751489);
const ivec2 char_plus = ivec2(-2130706432, 1057264);
const ivec2 char_comma = ivec2(16908800, 0);
const ivec2 char_hyphen = ivec2(0, 224);
const ivec2 char_period = ivec2(131072, 0);
const ivec2 char_slash = ivec2(1077936128, 4210752);
const ivec2 char_zero = ivec2(578945024, 136874258);
const ivec2 char_one = ivec2(-2130247680, 135798848);
const ivec2 char_two = ivec2(1078951936, 474251456);
const ivec2 char_three = ivec2(71761920, 1044398274);
const ivec2 char_four = ivec2(-503054336, 271601811);
const ivec2 char_five = ivec2(71761920, 1040480514);
const ivec2 char_six = ivec2(608632832, 403179762);
const ivec2 char_seven = ivec2(1082195968, 1044398144);
const ivec2 char_eight = ivec2(608632832, 474253538);
const ivec2 char_nine = ivec2(33751040, 474253794);
const ivec2 char_colon = ivec2(131072, 8192);
const ivec2 char_semicolon = ivec2(16908800, 8192);
const ivec2 char_less = ivec2(1090781184, 269488144);
const ivec2 char_equal = ivec2(-536870912, 63491);
const ivec2 char_greater = ivec2(16842752, 68174081);
const ivec2 char_question = ivec2(-2147352576, 474234944);
const ivec2 char_at = ivec2(-1605959680, 474278227);
const ivec2 char_A = ivec2(-465010688, 136874259);
const ivec2 char_B = ivec2(608665600, 507807986);
const ivec2 char_C = ivec2(608632832, 474220560);
const ivec2 char_D = ivec2(608665600, 507808018);
const ivec2 char_E = ivec2(542081024, 1040451824);
const ivec2 char_F = ivec2(541097984, 1040451824);
const ivec2 char_G = ivec2(609157120, 474220563);
const ivec2 char_H = ivec2(608731136, 574917106);
const ivec2 char_I = ivec2(-2130247680, 470818880);
const ivec2 char_J = ivec2(71761920, 541098242);
const ivec2 char_K = ivec2(-1572306944, 572794928);
const ivec2 char_L = ivec2(542081024, 33818640);
const ivec2 char_M = ivec2(608731136, 577546578);
const ivec2 char_N = ivec2(608731136, 574921043);
const ivec2 char_O = ivec2(608632832, 474253586);
const ivec2 char_P = ivec2(541097984, 507807984);
const ivec2 char_Q = ivec2(-1572143104, 474253586);
const ivec2 char_R = ivec2(-1572306944, 507807984);
const ivec2 char_S = ivec2(71761920, 474220770);
const ivec2 char_T = ivec2(-2130575360, 1041244224);
const ivec2 char_U = ivec2(608632832, 574916882);
const ivec2 char_V = ivec2(1090650112, 574916769);
const ivec2 char_W = ivec2(-1522204672, 574916946);
const ivec2 char_X = ivec2(1145602048, 574902337);
const ivec2 char_Y = ivec2(-2130575360, 574902336);
const ivec2 char_Z = ivec2(1078951936, 1044398144);
const ivec2 char_bracketleft = ivec2(1083113472, 1007161376);
const ivec2 char_backslash = ivec2(67108864, 266305);
const ivec2 char_bracketright = ivec2(34045952, 505430145);
const ivec2 char_asciicircum = ivec2(0, 136873984);
const ivec2 char_underscore = ivec2(1015808, 0);
const ivec2 char_quotereversed = ivec2(0, 135282688);
const ivec2 char_a = ivec2(-1001455616, 28931);
const ivec2 char_b = ivec2(608665600, 33847570);
const ivec2 char_c = ivec2(542048256, 61456);
const ivec2 char_d = ivec2(609157120, 541126930);
const ivec2 char_e = ivec2(-532217856, 28947);
const ivec2 char_f = ivec2(-2130575360, 269492448);
const ivec2 char_g = ivec2(609161244, 61714);
const ivec2 char_h = ivec2(608731136, 33847570);
const ivec2 char_i = ivec2(-2130247680, 134230080);
const ivec2 char_j = ivec2(-2130574332, 134225984);
const ivec2 char_k = ivec2(-1031208960, 67670176);
const ivec2 char_l = ivec2(-2130247680, 202383424);
const ivec2 char_m = ivec2(-1521844224, 22866);
const ivec2 char_n = ivec2(608731136, 30994);
const ivec2 char_o = ivec2(608632832, 28946);
const ivec2 char_p = ivec2(608665858, 30994);
const ivec2 char_q = ivec2(609161248, 61714);
const ivec2 char_r = ivec2(1082195968, 53344);
const ivec2 char_s = ivec2(-1006141440, 61457);
const ivec2 char_t = ivec2(-2130444288, 135295040);
const ivec2 char_u = ivec2(609157120, 35090);
const ivec2 char_v = ivec2(1115815936, 35089);
const ivec2 char_w = ivec2(-1522204672, 35090);
const ivec2 char_x = ivec2(-2104983552, 34976);
const ivec2 char_y = ivec2(609161244, 35090);
const ivec2 char_z = ivec2(-2138079232, 63616);
const ivec2 char_braceleft = ivec2(-2129920000, 806363168);
const ivec2 char_brokenbar = ivec2(-2130575360, 135274496);
const ivec2 char_braceright = ivec2(-2130608128, 101720192);
const ivec2 char_asciitilde = ivec2(0, 72630272);
const ivec2 char_filledbox = ivec2(-405831680, 1048377843);
const ivec2 char_sterling = ivec2(1083146240, 407375984);
const ivec2 char_quotesingle = ivec2(0, 135274496);
const ivec2 char_arrowleft = ivec2(1090519040, 1053168);
const ivec2 char_onehalf = ivec2(-1543240648, 33818641);
const ivec2 char_arrowright = ivec2(16777216, 1065457);
const ivec2 char_arrowup = ivec2(-2130706432, 1077584);
const ivec2 char_emdash = ivec2(0, 496);
const ivec2 char_onequarter = ivec2(1175067680, 67637282);
const ivec2 char_dblverticalbar = ivec2(1116012544, 338186401);
const ivec2 char_threequarters = ivec2(1711938592, 101718082);
const ivec2 char_divide = ivec2(16777216, 1049072);
const ivec2 char_comma_saa5051 = ivec2(8454400, 0);
const ivec2 char_period_saa5051 = ivec2(25362432, 0);
const ivec2 char_colon_saa5051 = ivec2(65536, 32);
const ivec2 char_semicolon_saa5051 = ivec2(8454400, 4096);
const ivec2 char_section = ivec2(596119836, 474220770);
const ivec2 char_Adieresis = ivec2(-465010688, 335573267);
const ivec2 char_Odieresis = ivec2(608632832, 335573266);
const ivec2 char_Udieresis = ivec2(608632832, 335579410);
const ivec2 char_degree = ivec2(0, 407396352);
const ivec2 char_adieresis = ivec2(-1001455616, 335573251);
const ivec2 char_odieresis = ivec2(608632832, 2621666);
const ivec2 char_udieresis = ivec2(609157120, 2621714);
const ivec2 char_germandbls = ivec2(608600322, 203704530);
const ivec2 char_currency = ivec2(1133019136, 35041);
const ivec2 char_Eacute = ivec2(-531660800, 269547537);
const ivec2 char_D_saa5052 = ivec2(1149698048, 474517794);
const ivec2 char_L_saa5052 = ivec2(1083113472, 67637280);
const ivec2 char_Aring = ivec2(-465010688, 134246675);
const ivec2 char_eacute = ivec2(-532217856, 269512979);
const ivec2 char_aring = ivec2(-1001455616, 134246659);
const ivec2 char_ccedilla = ivec2(542050312, 61456);
const ivec2 char_ugrave = ivec2(609157120, 68192530);
const ivec2 char_agrave = ivec2(-1001455616, 68186371);
const ivec2 char_ograve = ivec2(608632832, 68157666);
const ivec2 char_egrave = ivec2(-532217856, 68186387);
const ivec2 char_igrave = ivec2(-2130247680, 68157536);
const ivec2 char_idieresis = ivec2(-2130247680, 335556672);
const ivec2 char_edieresis = ivec2(-532217856, 335573267);
const ivec2 char_ecircumflex = ivec2(-532217856, 136868115);
const ivec2 char_ugrave_saa5054 = ivec2(609157120, 136349970);
const ivec2 char_icircumflex = ivec2(-2130247680, 136839264);
const ivec2 char_acircumflex = ivec2(-1001455616, 136868099);
const ivec2 char_ocircumflex_saa5054 = ivec2(608632832, 136868114);
const ivec2 char_ucircumflex = ivec2(609157120, 136839442);
const ivec2 char_ccedilla_saa5054 = ivec2(542050328, 61456);

float draw_char(vec2 coord, ivec2 char) {

  int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;

  int num = pos_id < 32 ? char.x : char.y;
  int val;

  if(pos_id < 32) {
    val = int(mod(float(num) / pow(2.0, float(pos_id)), 2.0));
  } else {
        // Handle the case where pos_id is greater than or equal to 32
        // by using a different bit manipulation technique.
    int shifted_pos_id = pos_id - 32;
    int pow_val = int(pow(2.0, float(shifted_pos_id)));
    val = (num / pow_val);
    val = val - (val / 2) * 2; // Use arithmetic to ensure val is 0 or 1
  }

  float col = val == 0 ? 0.0 : 1.0;

  return col;
}

// --------------------------------------------- Draw words

vec3 draw_text_pool(vec2 p, ivec2 text_box, vec4 text_coord) {
    // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[13];
  text_string_2[1] = ivec2(char_I);
  text_string_2[2] = ivec2(char_N);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_E);
  text_string_2[5] = ivec2(char_N);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_space);
  text_string_2[8] = ivec2(char_P);
  text_string_2[9] = ivec2(char_O);
  text_string_2[10] = ivec2(char_O);
  text_string_2[11] = ivec2(char_L);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];
  else if(charIndex == 10)
    current_char = text_string_2[10];
  else if(charIndex == 11)
    current_char = text_string_2[11];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_you(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[4];
  text_string_2[1] = ivec2(char_Y);
  text_string_2[2] = ivec2(char_O);
  text_string_2[3] = ivec2(char_U);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_hedger(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[7];
  text_string_2[1] = ivec2(char_H);
  text_string_2[2] = ivec2(char_E);
  text_string_2[3] = ivec2(char_D);
  text_string_2[4] = ivec2(char_G);
  text_string_2[5] = ivec2(char_E);
  text_string_2[6] = ivec2(char_R);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_party_a(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[8];
  text_string_2[1] = ivec2(char_P);
  text_string_2[2] = ivec2(char_A);
  text_string_2[3] = ivec2(char_R);
  text_string_2[4] = ivec2(char_T);
  text_string_2[5] = ivec2(char_Y);
  text_string_2[6] = ivec2(char_space);
  text_string_2[7] = ivec2(char_A);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_party_b(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[8];
  text_string_2[1] = ivec2(char_P);
  text_string_2[2] = ivec2(char_A);
  text_string_2[3] = ivec2(char_R);
  text_string_2[4] = ivec2(char_T);
  text_string_2[5] = ivec2(char_Y);
  text_string_2[6] = ivec2(char_space);
  text_string_2[7] = ivec2(char_B);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_intent_a(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[9];
  text_string_2[1] = ivec2(char_I);
  text_string_2[2] = ivec2(char_N);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_E);
  text_string_2[5] = ivec2(char_N);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_space);
  text_string_2[8] = ivec2(char_A);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}
vec3 draw_text_intent_b(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[9];
  text_string_2[1] = ivec2(char_I);
  text_string_2[2] = ivec2(char_N);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_E);
  text_string_2[5] = ivec2(char_N);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_space);
  text_string_2[8] = ivec2(char_B);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_liquidator(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

  // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[11];
  text_string_2[1] = ivec2(char_L);
  text_string_2[2] = ivec2(char_I);
  text_string_2[3] = ivec2(char_Q);
  text_string_2[4] = ivec2(char_U);
  text_string_2[5] = ivec2(char_I);
  text_string_2[6] = ivec2(char_D);
  text_string_2[7] = ivec2(char_A);
  text_string_2[8] = ivec2(char_T);
  text_string_2[9] = ivec2(char_O);
  text_string_2[10] = ivec2(char_R);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

  //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];
  else if(charIndex == 10)
    current_char = text_string_2[10];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_execute(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[8];
  text_string_2[1] = ivec2(char_E);
  text_string_2[2] = ivec2(char_X);
  text_string_2[3] = ivec2(char_E);
  text_string_2[4] = ivec2(char_C);
  text_string_2[5] = ivec2(char_U);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_E);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_liquidate(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[10];
  text_string_2[1] = ivec2(char_L);
  text_string_2[2] = ivec2(char_I);
  text_string_2[3] = ivec2(char_Q);
  text_string_2[4] = ivec2(char_U);
  text_string_2[5] = ivec2(char_I);
  text_string_2[6] = ivec2(char_D);
  text_string_2[7] = ivec2(char_A);
  text_string_2[8] = ivec2(char_T);
  text_string_2[9] = ivec2(char_E);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_minus100(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[7];
  text_string_2[1] = ivec2(char_emdash);
  text_string_2[2] = ivec2(char_space);
  text_string_2[3] = ivec2(char_dollar);
  text_string_2[4] = ivec2(char_one);
  text_string_2[5] = ivec2(char_zero);
  text_string_2[6] = ivec2(char_zero);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_plus100(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[7];
  text_string_2[1] = ivec2(char_plus);
  text_string_2[2] = ivec2(char_space);
  text_string_2[3] = ivec2(char_dollar);
  text_string_2[4] = ivec2(char_one);
  text_string_2[5] = ivec2(char_zero);
  text_string_2[6] = ivec2(char_zero);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_btc_short(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

  // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[11];
  text_string_2[1] = ivec2(char_one);
  text_string_2[2] = ivec2(char_B);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_C);
  text_string_2[5] = ivec2(char_space);
  text_string_2[6] = ivec2(char_S);
  text_string_2[7] = ivec2(char_H);
  text_string_2[8] = ivec2(char_O);
  text_string_2[9] = ivec2(char_R);
  text_string_2[10] = ivec2(char_T);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

  //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];
  else if(charIndex == 10)
    current_char = text_string_2[10];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_btc_long(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

  // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[10];
  text_string_2[1] = ivec2(char_one);
  text_string_2[2] = ivec2(char_B);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_C);
  text_string_2[5] = ivec2(char_space);
  text_string_2[6] = ivec2(char_L);
  text_string_2[7] = ivec2(char_O);
  text_string_2[8] = ivec2(char_N);
  text_string_2[9] = ivec2(char_G);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

  //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}




vec3 draw_text_lock(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[5];
  text_string_2[1] = ivec2(char_L);
  text_string_2[2] = ivec2(char_O);
  text_string_2[3] = ivec2(char_C);
  text_string_2[4] = ivec2(char_K);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_dash(vec2 p, ivec2 text_box, vec4 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[5];
  text_string_2[1] = ivec2(char_emdash);
  text_string_2[2] = ivec2(char_emdash);
  text_string_2[3] = ivec2(char_emdash);
  text_string_2[4] = ivec2(char_emdash);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}
//-------------------------------------------- Triangles and animation Rendering

const float k = sqrt(3.0);

ivec2 text_box_chars = ivec2(13, 7);
vec4 text_coord; // Scale.xy   Position.zw

vec3 eyeRender(vec3 col, vec2 p, float vis) {
  // Calculate blink
  float eyeBlink = smoothstep(-0.28, 0.2, mod(iTime, 0.0));
  eyeBlink -= smoothstep(0.28, 0.4, mod(iTime, 2.5));
  // REPLACEMENT
  vec2 rotatedP = vec2(-p.y + 0.2, p.x);
  // Calculate Almond Eye
  float bl = 1.0;
  bl *= vis;
  float k = -clamp(bl * bl, 0.06, 1.0);
  vec2 pos = vec2(-4.0 * rotatedP.y, 4.0 * rotatedP.x);
  pos = abs(pos);
  float ik = 1.0 / k;
  float parabola_p = ik * (pos.y - 1.1 * ik) / 3.0;
  float parabola_q = 0.25 * ik * ik * pos.x;
  float parabola_h = parabola_q * parabola_q - parabola_p * parabola_p * parabola_p;
  float parabola_r = sqrt(abs(parabola_h));
  float parabola_x = (parabola_h > 0.0) ? pow(parabola_q + parabola_r, 1.0 / 3.0) - pow(abs(parabola_q - parabola_r), 1.0 / 3.0) * sign(parabola_r - parabola_q) : 2.0 * cos(atan(parabola_r, parabola_q) / 3.0) * sqrt(parabola_p);

  float sdEye = length(pos - vec2(parabola_x, k * parabola_x * parabola_x)) * sign(pos.x - parabola_x) - bl + 0.06;

  // Apply smoothstep to color using sdEye
  col += smoothstep(0.015, 0.025, abs(sdEye));
  // Eye core creation and reposition
  vec2 adjustedMousePos = vec2(-mousePos.y, 1.1 * (-mousePos.x)) * 2.0;
  vec2 diff = 2.0 * rotatedP - adjustedMousePos;
  float distance = length(diff) - 0.3 - 2.0 * smoothstep(0.895, 0.9, 0.0);
  float eyeMask = max(distance, sdEye);
  col = min(col, smoothstep(-0.01, 0.0, eyeMask * vis));
  return col;
}



vec3 tri_half_left(vec3 col, vec3 ro, vec3 rd, vec3 text, vec2 tri_pos) {
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy * 0.5;
  p.y -= 0.58;
  p += tri_pos;
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  vec3 glow_col = vec3(0.008, 0.001, 0.001);

  // Cut the triangle into left and right halves
  if (p.x > 0.0) {
    // Calculate the left half
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
    p.x -= clamp(p.x, -2.0, 0.0);
    float dt = -length(p) * sign(p.y);
    col = mix((dt < -0.0) ? fillColor : col, col, 0.0);
    col += glow_col / max(abs(dt), 0.001);
    col = mix(col, vec3(1.0, 0.4, 0.4), text);
  } else {
    // Calculate the right half
    // Modify the right half calculations here as needed
    // You can use a different set of equations to create the right half effect
  }

  return col;
}


vec3 tri_half_right(vec3 col, vec3 ro, vec3 rd, vec3 text, vec2 tri_pos ,vec2 text_vis_pos) {
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy * 0.5;
  vec2 p_text = p;
  p += tri_pos;
  p.x = -p.x;
  p.y -= 0.58;
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  vec3 glow_col = vec3(0.008, 0.001, 0.001);

  // Cut the triangle into left and right halves
  if (p.x > 0.0) {
    // Calculate the left half
    p.x = abs(p.x) - 1.0;
    p.y = p.y + 1.0 / k;
    p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
    p.x -= clamp(p.x, -2.0, 0.0);
    float dt = -length(p) * sign(p.y);
    col = mix((dt < -0.0) ? fillColor : col, col, 0.0);
    col += glow_col / max(abs(dt), 0.001);
    col = mix(col, vec3(1.0, 0.4, 0.4), text);
  } 

  text_coord = vec4(0.75, -0.32+text_vis_pos.y, 0.35+(text_vis_pos.x/6.0), 0.0); // Scale.x   Position.yz
  col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_minus100(p_text, text_box_chars, text_coord)*text_vis_pos.x );

  text_coord = vec4(0.75, 0.95-text_vis_pos.y, 0.35+(text_vis_pos.x/6.0), 0.0); // Scale.x   Position.yz
  col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_plus100(p_text, text_box_chars, text_coord)*text_vis_pos.x );

  text_coord = vec4(0.75, 1.0, 0.65, 0.0); // Scale.x   Position.yz
  col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_party_a(p_text, text_box_chars, text_coord)*(1.0-iAnimProgress_4.x));
  text_coord = vec4(0.75, -0.3, 0.65, 0.0); // Scale.x   Position.yz
  col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_party_b(p_text, text_box_chars, text_coord)*(1.0-iAnimProgress_4.x));


  return col;
}




vec3 triRender(vec3 col, vec3 ro, vec3 rd, float text_selector, vec2 tri_pos, float tri_scl, float tri_vis, vec3 glow_color) {
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy * 0.5;
  p.y -= 0.58;
  p += tri_pos;
  p *= tri_scl;
  vec2 p_text = p;
  vec3 glow_col = glow_color;
  p.x = abs(p.x) - 1.0;
  p.y = p.y + 1.0 / k;
  p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
  p.x -= clamp(p.x, -2.0, 0.0);
  float dt = -length(p) * sign(p.y);
  col = mix((dt < -0.0) ? fillColor : col, col, 1.0 - tri_vis);
  vec3 tri_col = col;
  col += glow_col / max(abs(dt), 0.001);

    //  YOU
  if(text_selector == 1.0) {
    text_coord = vec4(1.5, 0.2, 1.03, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_you(p_text, text_box_chars, text_coord));
  }
    // HEDGER
  else if(text_selector == 2.0) {
    text_coord = vec4(1.5, 0.3, 1.03, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_hedger(p_text, text_box_chars, text_coord));
  }

    //  INTENT POOL
  else if(text_selector == 3.0) {
    text_coord = vec4(0.9, 0.48, 0.4, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.4, 0.4), draw_text_pool(p_text, text_box_chars, text_coord));
  }

    //  PARTY A
  else if(text_selector == 4.0) {
    text_coord = vec4(1.3, 0.34, 0.75, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_party_a(p_text, text_box_chars, text_coord));
  }

    //  PARTY B
  else if(text_selector == 5.0) {
    text_coord = vec4(1.3, 0.34, 0.75, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_party_b(p_text, text_box_chars, text_coord));
  }

    //  INTENT A
  else if(text_selector == 6.0) {
    text_coord = vec4(1.3, 0.35, 0.75, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_intent_a(p_text, text_box_chars, text_coord));
  }

    //  INTENT B
  else if(text_selector == 7.0) {
    text_coord = vec4(1.3, 0.34, 0.95, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_intent_b(p_text, text_box_chars, text_coord));
  }

    //  LIQUIDATOR
  else if(text_selector == 8.0) {
    text_coord = vec4(1.3, 0.45, 1.0, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_liquidator(p_text, text_box_chars, text_coord) * tri_vis);
    col = mix(glow_color * 1000.0, col, eyeRender(col, p_text, 1.0));

  }
    //  EXECUTE
  else if(text_selector == 9.0) {
    text_coord = vec4(1.3, 0.45, 1.0, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_execute(p_text, text_box_chars, text_coord) * tri_vis);
  }
    // YOU   +    INTENT A
  else if(text_selector == 23.0) {
    text_coord = vec4(1.5, 0.40, 0.85, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_intent_a(p_text, text_box_chars, text_coord));
    text_coord = vec4(1.5, 0.2, 1.03, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_you(p_text, text_box_chars, text_coord));
  }
    // PARTY A   +    INTENT A
  else if(text_selector == 24.0) {
    text_coord = vec4(1.5, 0.38 - (iAnimProgress_2.z * 1.5), 0.85, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_intent_a(p_text, text_box_chars, text_coord));
    text_coord = vec4(1.5, 0.32, 1.03, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_party_a(p_text, text_box_chars, text_coord));
  }

    // PARTY B   +    INTENT B
  else if(text_selector == 25.0) {
    text_coord = vec4(1.5, 0.38 + (iAnimProgress_2.z * 1.55), 0.85, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_intent_b(p_text, text_box_chars, text_coord));
    text_coord = vec4(1.5, 0.34, 1.03, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_party_b(p_text, text_box_chars, text_coord));
  }

    // LIQUIDATOR  +  EXECUTE + PARTY B TRADE
  else if(text_selector == 26.0) {
    text_coord = vec4(1.3, 0.45, 1.0, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_liquidator(p_text, text_box_chars, text_coord) * tri_vis);

    text_coord = vec4(2.6, 0.33, 1.2, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_execute(p_text, text_box_chars, text_coord) * tri_vis);

    text_coord = vec4(1.5, -0.35, 1.85 +(tri_vis/6.0), 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_minus100(p_text, text_box_chars, text_coord) * tri_vis);

    text_coord = vec4(1.5, 0.95, 1.85 +(tri_vis/6.0), 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_plus100(p_text, text_box_chars, text_coord) * tri_vis);

    col = mix(glow_color * 1000.0, col, eyeRender(col, p_text, 1.0));

  }

    // LIQUIDATOR  +  EXECUTE + PARTY A TRADE
  else if(text_selector == 27.0) {
    text_coord = vec4(1.3, 0.45, 1.0, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_liquidator(p_text, text_box_chars, text_coord) * tri_vis);
    text_coord = vec4(2.6, 0.33, 1.2, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_execute(p_text, text_box_chars, text_coord) * tri_vis);

    text_coord = vec4(1.5, 0.95, 1.85 +(tri_vis/6.0), 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_minus100(p_text, text_box_chars, text_coord) * tri_vis);

    text_coord = vec4(1.5, -0.35, 1.85 +(tri_vis/6.0), 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_plus100(p_text, text_box_chars, text_coord) * tri_vis);

    col = mix(glow_color * 1000.0, col, eyeRender(col, p_text, 1.0));

  }
    // LIQUIDATOR  +  LIQUIDATE + PARTY A LIQUIDATE
  else if(text_selector == 28.0) {
    // Scale, right-left, up-down, unused 
    text_coord = vec4(1.3, 0.45, 1.0, 0.0);
    col = mix(col, vec3(1.0), draw_text_liquidator(p_text, text_box_chars, text_coord) * tri_vis);
 
    // Scale, right-left, up-down, unused 
    text_coord = vec4(2.6, 0.4, 1.2, 0.0);
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_liquidate(p_text, text_box_chars, text_coord) * tri_vis);

    // Scale, right-left, up-down, unused 
    text_coord = vec4(1.5, 0.95, 1.85 +(tri_vis/6.0), 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_minus100(p_text, text_box_chars, text_coord) * tri_vis);
    
    // Scale, right-left, up-down, unused 
    text_coord = vec4(3.0, 0.55, 1.49, 0.0);
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_dash(p_text, text_box_chars, text_coord) * tri_vis);

    col = mix(glow_color * 1000.0, col, eyeRender(col, p_text, 1.0));

  }

    // LIQUIDATOR  +  LIQUIDATE + PARTY B LIQUIDATE
  else if(text_selector == 29.0) {
    // Scale, right-left, up-down, unused 
    text_coord = vec4(1.3, 0.45, 1.0, 0.0);
    col = mix(col, vec3(1.0), draw_text_liquidator(p_text, text_box_chars, text_coord) * tri_vis);

    // Scale, right-left, up-down, unused 
    text_coord = vec4(2.6, 0.4, 1.2, 0.0);
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_liquidate(p_text, text_box_chars, text_coord) * tri_vis);

    // Scale, right-left, up-down, unused 
    text_coord = vec4(1.5, -0.35, 1.85 +(tri_vis/6.0), 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_minus100(p_text, text_box_chars, text_coord) * tri_vis);

    // Scale, right-left, up-down, unused 
    text_coord = vec4(3.0, -0.10, 1.49, 0.0);
    col = mix(col, vec3(1.0, 0.0, 0.0), draw_text_dash(p_text, text_box_chars, text_coord) * tri_vis);

    col = mix(glow_color * 1000.0, col, eyeRender(col, p_text, 1.0));

  }

    // PARTY A + PARTY B
  else if(text_selector == 30.0) {
    // Scale, right-left, up-down, unused 
    text_coord = vec4(0.75, 0.98, 1.42, 0.0);
    col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_party_a(p_text, text_box_chars, text_coord));
    // Scale, right-left, up-down, unused 
    text_coord = vec4(0.75, -0.32, 1.42, 0.0);
    col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_party_b(p_text, text_box_chars, text_coord));
  }

    // PARTY A   +    1BTC SHORT
  else if(text_selector == 31.0) {
    text_coord = vec4(1.5, 0.38 - (iAnimProgress_2.z * 1.23), 0.85, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_btc_short(p_text, text_box_chars, text_coord));
    text_coord = vec4(1.5, 0.32, 1.03, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0), draw_text_party_a(p_text, text_box_chars, text_coord));
  }

    // PARTY B   +    1BTC LONG
  else if(text_selector == 32.0) {
    text_coord = vec4(1.5, 0.38 + (iAnimProgress_2.z * 1.36), 0.85, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 1.0, 1.0), draw_text_btc_long(p_text, text_box_chars, text_coord));
    text_coord = vec4(1.5, 0.34, 1.03, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.2, 0.2), draw_text_party_b(p_text, text_box_chars, text_coord));
  }

    //  INTENT POOL + LOCK
  else if(text_selector == 33.0) {
    text_coord = vec4(0.9, 0.48, 0.4, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(1.0, 0.4, 0.4), draw_text_pool(p_text, text_box_chars, text_coord));
    text_coord = vec4(1.2, 0.25, 0.7, 0.0); // Scale.x   Position.yz
    col = mix(col, vec3(0.5, 0.5, 0.5), draw_text_lock(p_text, text_box_chars, text_coord));
  }
  return col;
}

vec3 glow_color;
float text_selector = 0.0;
float text_selector_2 = 0.0;
vec2 tri_pos;
float tri_scl = 1.0;
float tri_vis = 1.0;
float tri2_vis = 1.0;

vec3 anim_render(vec3 col, vec3 ro, vec3 rd) {
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy;

  //////////////////////////////  HOME SCREEN
  if(iAnimProgress_1.x >= 0.0 && iAnimProgress_1.x < 0.5) {
        //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 0.0;
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);
  }

/////////////////////////////// HOW TO TRADE TITLE
  else if(iAnimProgress_1.x >= 0.5 && iAnimProgress_1.y < 0.5) {
        //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 3.0; //draw_text_pool
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

        //right triangle
    tri_pos = vec2(0.0 + iAnimProgress_1.x, 0.29);
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.01, 0.0005, 0.0005) - iAnimProgress_1.x * vec3(0.008, 0.0004, 0.0004);
    text_selector = 2.0; //draw_text_hedger
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

        //left triangle
    tri_pos = vec2(0.0 - iAnimProgress_1.x, 0.29);
    tri_vis = 0.0 + iAnimProgress_1.x;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005) - iAnimProgress_1.x * vec3(0.004);
    text_selector = 1.0; //draw_text_you
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  }

//////////////////////////////////   Formulate INTENT
  else if(iAnimProgress_1.y >= 0.5 && iAnimProgress_1.z < 0.5) {
        //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 3.0; //draw_text_pool
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

        //right triangle
    tri_pos = vec2(0.0 + iAnimProgress_1.x, 0.29);
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.01, 0.0005, 0.0005) - iAnimProgress_1.x * vec3(0.008, 0.0004, 0.0004);
    text_selector = 2.0; //draw_text_hedger
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

        //left triangle
    tri_pos = vec2(-1.0 + (iAnimProgress_1.z * 0.5), 0.29);
    tri_vis = 0.0 + iAnimProgress_1.x;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005);
    text_selector = 23.0; //draw_text_you   +   intent a
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);
  }

////////////////////////////////// Send your intent to pool
  else if(iAnimProgress_1.z >= 0.5 && iAnimProgress_2.x < 0.5) {
      //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 3.0; //draw_text_pool
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

      //right triangle
    tri_pos = vec2(0.0 + iAnimProgress_1.x, 0.29);
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.01, 0.0005, 0.0005) - iAnimProgress_1.x * vec3(0.008, 0.0004, 0.0004);
    text_selector = 2.0; //draw_text_hedger
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

      //left triangle
    tri_pos = vec2(-1.0 + (iAnimProgress_1.z * 0.5), 0.29);
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005);
    text_selector = 24.0; // PARTY A + INTENT A
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);
  }  
  ///////////////////////////////////// HEDGER sees your intent
  else if(iAnimProgress_2.x >= 0.5 && iAnimProgress_2.y < 0.5) {
    //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 3.0; //draw_text_pool
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

    //right triangle
    tri_pos = vec2(1.0 - iAnimProgress_2.y * 0.5, 0.29);
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.006, 0.0001, 0.0001);
    text_selector = 2.0; //draw_text_hedger
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

    //left triangle
    tri_pos = vec2(-1.0 + (iAnimProgress_1.z * 0.5), 0.29);
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005);
    text_selector = 24.0; // PARTY A + INTENT A
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);
  }

  ////////////////////////// HEDGER claims your intent
  else if(iAnimProgress_2.y >= 0.5 && iAnimProgress_2.z < 0.5) {
  //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 3.0; //draw_text_pool
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  //right triangle
    tri_pos = vec2(1.0 - iAnimProgress_2.y * 0.5, 0.29);
    tri_vis = 1.0 - iAnimProgress_2.z;
    tri_scl = 2.0;
    glow_color = vec3(0.006, 0.0001, 0.0001);
    text_selector = 25.0; //draw_text_part_b
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  //left triangle
    tri_pos = vec2(-0.5, 0.29);
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005);
    text_selector = 24.0; //draw_text_part_a
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);
  }

/////////////////////////////INTENTS CREATE a trade
  else if(iAnimProgress_2.z >= 0.5 && iAnimProgress_3.x < 0.5) {
  //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 3.0; //draw_text_pool
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  //right triangle
    tri_pos = vec2(1.0 - iAnimProgress_2.y * 0.5, 0.29);
    tri_vis = 0.0;
    tri_scl = 2.0;
    glow_color = vec3(0.006, 0.0001, 0.0001) * (1.0 - iAnimProgress_3.y);
    text_selector = 32.0; // PARTY B + 1BTC LONG
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  //left triangle
    tri_pos = vec2(-1.0 + (iAnimProgress_1.z * 0.5), 0.29);
    tri_vis = 0.0 - iAnimProgress_2.y;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005) * (1.0 - iAnimProgress_3.y);
    text_selector = 31.0; // PARTY A + 1BTC SHORT
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);
  } 
////////////////////////Section Both parties lock collateral
else if(iAnimProgress_3.x >= 0.5 && iAnimProgress_3.y < 0.5) {
  //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 33.0; //draw_text_pool
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  //right triangle
    tri_pos = vec2(1.0 - iAnimProgress_2.y * 0.5, 0.29);
    tri_vis = 0.0;
    tri_scl = 2.0;
    glow_color = vec3(0.006, 0.0001, 0.0001) * (1.0 - iAnimProgress_3.y);
    text_selector = 32.0; // PARTY B + 1BTC LONG
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  //left triangle
    tri_pos = vec2(-1.0 + (iAnimProgress_1.z * 0.5), 0.29);
    tri_vis = 0.0 - iAnimProgress_2.y;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005) * (1.0 - iAnimProgress_3.y);
    text_selector = 31.0; // PARTY A + 1BTC SHORT
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);
  } 
//////////////*********////////////Section watch dogs
  else if(iAnimProgress_3.y >= 0.5 && iAnimProgress_3.z < 0.5) {
  //middle triangle
    tri_vis = 1.0;
    tri_scl = 1.0;
    glow_color = vec3(0.008, 0.001, 0.001);
    text_selector = 30.0; // PARTY A + PARTY B
    tri_pos = vec2(0.0, 0.0);
    col = triRender(col, ro, rd, text_selector, tri_pos, tri_scl, tri_vis, glow_color);

  //Liquidator triangle
    tri_pos = vec2(0.0 + sin(iTime), -1.57 + cos(iTime));
    tri_vis = 1.0;
    tri_scl = 2.0;
    glow_color = vec3(0.005, 0.005, 0.005);
    text_selector = 8.0; // LIQUIDATOR
    vec2 anim = vec2(cos(iTime), sin(iTime));
    vec2 anim2 = vec2(cos(iTime + 3.14), sin(iTime + 3.14));
    float anim_tik = cos(iTime / 3.0);
    float anim_tik_2 = cos((iTime + 3.14) / 3.0);

    int anim_sh = 0;
    if(anim_tik < -0.5) {
      anim_sh = 1;
    } else {
      anim_sh = 0;
    }

    int anim_sh_2 = 0;
    if(anim_tik_2 > 0.5) {
      anim_sh_2 = 1;
    } else {
      anim_sh_2 = 0;
    }

  //---------------------Tri 1 Animation
  //   Quadrant I
    if((anim.x > 0.0 && anim.y < 0.0)) {
      tri_vis = 1.0 * anim.x;
      glow_color = vec3(0.005, 0.005, 0.005) * anim.x;
      text_selector = 8.0; // LIQUIDATOR
      col = triRender(col, ro, rd, text_selector, vec2(anim.x, anim.y - 1.57), tri_scl, tri_vis, glow_color);
    }

    //   Quadrant II
    else if((anim.x < 0.0 && anim.y < 0.0)) {

    }
  //   Quadrant III
    else if((anim.x < 0.0 && anim.y > 0.0)) {
      glow_color = vec3(0.005, 0.005, 0.005) * (sin(iTime));
      text_selector = 26.0; // LIQUIDATOR  +  EXECUTE
      if(anim_sh == 1) {
        text_selector = 28.0; // LIQUIDATOR
        glow_color = vec3(0.002, 0.0005, 0.0005) * (sin(iTime));
      }
      tri_vis = 1.0 * (sin(iTime));
      anim.x = 0.0;
      anim.y = 1.0;
      col = triRender(col, ro, rd, text_selector, vec2(anim.x, anim.y - 1.57), tri_scl, tri_vis, glow_color);

    }

  //   Quadrant IV
    else if((anim.x > 0.0 && anim.y > 0.0)) {
      glow_color = vec3(0.005, 0.005, 0.005);
      text_selector_2 = 8.0; // LIQUIDATOR
      col = triRender(col, ro, rd, text_selector, vec2(anim.x, anim.y - 1.57), tri_scl, tri_vis, glow_color);
    }

  //---------------------Tri 2 Animation
  //Quadrant I
    if((anim2.x > 0.0 && anim2.y < 0.0)) {
      tri_vis = anim2.x;
      glow_color = vec3(0.005, 0.005, 0.005) * anim2.x;
      text_selector_2 = 8.0; // LIQUIDATOR
      col = triRender(col, ro, rd, text_selector_2, vec2(anim2.x, anim2.y - 1.57), tri_scl, tri_vis, glow_color);

  //Quadrant II
    } else if((anim2.x < 0.0 && anim2.y < 0.0)) {

  //Quadrant III
    } else if((anim2.x < 0.0 && anim2.y > 0.0)) {
      text_selector_2 = 27.0; // LIQUIDATOR
      glow_color = vec3(0.005, 0.005, 0.005) * anim2.y;
      if(anim_sh_2 == 1) {
        text_selector_2 = 29.0; // LIQUIDATOR
        glow_color = vec3(0.002, 0.0005, 0.0005) * anim2.y;
      }
      tri_vis = 1.0 * anim2.y;
      anim2.x = 0.0;
      anim2.y = 1.0;
      col = triRender(col, ro, rd, text_selector_2, vec2(anim2.x, anim2.y - 1.57), tri_scl, tri_vis, glow_color);

  //Quadrant IV Tri 2
    } else if((anim2.x > 0.0 && anim2.y > 0.0)) {
      text_selector_2 = 8.0; // LIQUIDATOR
      col = triRender(col, ro, rd, text_selector_2, vec2(anim2.x, anim2.y - 1.57), tri_scl, tri_vis, glow_color);

    }

  }


/////////***********/////////////// PARTY A PARTY B are SYMMETRICAL
  else if(iAnimProgress_3.z >= 0.5 && iAnimProgress_4.x < 0.5) {
    vec2 text_vis_pos = vec2(0.0,0.0);
    if (cos(iTime) < 0.0 && sin(iTime) > 0.0) {
      text_vis_pos.x = sin(iTime);
    } else if (cos(iTime) > 0.0 && sin(iTime) < 0.0) {
      text_vis_pos.x = -sin(iTime);
      text_vis_pos.y = 1.25;
    }
    col = tri_half_left(col, ro,rd, vec3(0.0),vec2(0.0-(iAnimProgress_3.z-iAnimProgress_4.x)*0.1,0.0));
    col = tri_half_right(col, ro,rd, vec3(0.0),vec2(0.0+(iAnimProgress_3.z-iAnimProgress_4.x)*0.1,0.0), text_vis_pos);
  }


/////////***********/////////////// Know more
else if(iAnimProgress_4.x >= 0.5 && iAnimProgress_4.y < 0.5 ) {
    vec2 text_vis_pos = vec2(0.0,0.0);
    text_vis_pos.x = 0.0;
    col = tri_half_left(col, ro,rd, vec3(0.0),vec2(0.0-(iAnimProgress_3.z-iAnimProgress_4.x)*0.1,0.0));
    col = tri_half_right(col, ro,rd, vec3(0.0),vec2(0.0+(iAnimProgress_3.z-iAnimProgress_4.x)*0.1,0.0), text_vis_pos);

  }
  
  return col;
}

//-------------------------------------------- Sky and ground rendering
vec2 tilesSize = vec2(1.0);
const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));
const vec4 gpdim = vec4(gpn, 0.0);
vec3 sunDir = normalize(vec3(0.0, -2.0, 20.0));
const vec3 sunCol = vec3(0.0015, 0.001, 0.001);

vec3 outerSkyRender(vec3 ro, vec3 rd) {
  vec3 col = vec3(0.1, 0.1, 0.1);
  float sunDot = dot(sunDir, rd);
  if(sunDot > 0.0) {
    col += sunCol / pow(1.002 - sunDot, 1.9 - iAnimProgress_1.x + iAnimProgress_3.y/2.0);
  }
  vec3 gcol = vec3(0.003 - iAnimProgress_1.x * 0.0025);
  col += gcol / max(abs(rd.y), 0.0001);
  return col;
}

vec3 groundRender(vec3 col, vec3 ro, vec3 rd) {
  float gpd = -(dot(ro, gpdim.xyz) + gpdim.w) / dot(rd, gpdim.xyz);
  if(gpd < 0.0) {
    return col;
  }
  vec3 gp = ro + rd * gpd;
  float gpfre = 1.15 + dot(rd, gpn);
  gpfre *= gpfre * gpfre * gpfre; // Reduce power operations
  vec3 grr = reflect(rd, gpn);
  vec2 ggp = gp.xz;
  ggp.y += iTime;
  float dfy = dFdy(ggp.y);
  float gcf = sin(ggp.x) * sin(ggp.y);
  ggp = mod(ggp + tilesSize * 0.5, tilesSize) - tilesSize * 0.5;
  float ggd = min(abs(ggp.x), abs(ggp.y));
  vec3 glow_col = vec3(0.002, 0.001, 0.001);
  vec3 rcol = outerSkyRender(grr, grr);
  rcol = anim_render(rcol, gp, grr);

  col = glow_col / max(ggd, 0.0 + 0.25 * dfy);
  col += rcol * gpfre / 2.0;

    //change the reflection value
  col *= 1.0 - (iAnimProgress_1.x * 0.7);
  return col;
}
vec3 ro;
vec3 la;
void mainImage(out vec4 fragColor, in vec2 fragCoord) {




  //****************--------Vertical mode

  if (iResolution.x < iResolution.y){
// Camera look at       
    la = vec3(
      //Right, Left
      0.0,
      //Up, Down
      20.5+iAnimProgress_1.x*7.0,
      //Forth ,Back 
      60.0);

// Camera location
    ro = vec3(
      //Right, Left
      0.0,
      //Up, Down
      0.5,
      //Forth ,Back 
      -8.0-iAnimProgress_1.x*2.0+iAnimProgress_4.x*8.0);
  

  //***************-------Desktop/Horizontal mode

  } else {

// Camera look at       
    la = vec3(
      //Right, Left
      0.0+iAnimProgress_1.x*2.0,
      //Up, Down
      20.5+iAnimProgress_3.y*8.0-iAnimProgress_3.z*5.0+iAnimProgress_4.x*10.0,
      //Forth ,Back 
      100.0);

// Camera location
    ro = vec3(
      //Right, Left
      0.0+iAnimProgress_1.x*2.0,
      //Up, Down
      0.5  -iAnimProgress_3.z*0.2  -iAnimProgress_4.x*0.2,
      //Forth ,Back 
      -5.0+iAnimProgress_3.x*1.0+iAnimProgress_3.z*1.1+iAnimProgress_4.x*3.1);
  }

  vec2 q = fragCoord / iResolution.xy;
  vec2 p = -1.0 + 2.0 * q;
  p.x *= iResolution.x / iResolution.y;
  const float fov = 2.0;
  const vec3 up = vec3(0.0, 1.0, 0.0);
  vec3 ww = normalize(la - ro);
  vec3 uu = normalize(cross(up, ww));
  vec3 vv = cross(ww, uu);
  vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);
  vec3 col = outerSkyRender(rd, rd);
  col = groundRender(col, ro, rd);
  col = anim_render(col, ro, rd);
  fragColor = vec4(col, 1.0);
}

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
</script>

<script src="./threeJsHome.js"></script>