<!doctype html>
<html lang="en">

<header>
  <title>SYMMIO</title>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="jQuerySet.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>

  <script src="https://unpkg.com/gsap@3.5.1/dist/ScrollTrigger.min.js"></script>
  <script src="https://unpkg.com/gsap@3.5.1/dist/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.4.0/TextPlugin.min.js"></script>
  <script src="gsapHome.js"></script>

  <link rel="stylesheet" href="styleHome.css">
  <link rel="stylesheet" href="navbar.css">

  <nav>
    <ul class="menu__list">
      <li class="menu__item">
        <button class="menu__link" href="#Home">Home</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#HowItWorks">How it works</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#reachus">learn more</button>
      </li>
      <li><button class="reset">Trade</button>
      </li>
    </ul>
  </nav>


</header>

<body>

  <div id="webgl-container"></div>

  <input type="checkbox" id="menu_trigger" class="menu-trigger">
  <div class="overlay">
    <ul class="menu-links">
      <li><a id="link1" href="#Home">Home</a></li>
      <li><a id="link2" href="#HowItWorks">How it works</a></li>
      <li><a id="link3" href="#reachus">learn more</a></li>
      <li><a id="link4" class="red" href="#">TRADE</a></li>
    </ul>
  </div>
  <label for="menu_trigger" class="hamburger-menu">
    <span></span>
    <span></span>
    <span></span>
  </label>

  <script>
    // --------------Hambergur menu script
    const menuTrigger = document.querySelector('.menu-trigger');
    const overlay = document.querySelector('.overlay');

    // Get references to all menu links
    const menuLinks = document.querySelectorAll('.menu-links li a');

    // Add a click event listener to each menu link
    menuLinks.forEach(link => {
      link.addEventListener('click', () => {
        // Hide the overlay
        if (menuTrigger.checked = true) {
          menuTrigger.checked = false;
        }
      });
    });
  </script>

  <div class="section one " id="Home">
    <a class="scrollDown">
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="text">[ more ]</span>
    </a>

    <div class="caption ">
      A protocol for SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>
    <div class="captionMobile ">
      <span class="first-line">A protocol for</span><br>
      SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>

    <div class="box__text">

      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section two" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section three" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section four" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="subtitle"></div>
      <div class="title"></div>
    </div>
  </div>

  <div class="section five" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section six" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section seven" id="HowItWorks">
    <div class="box__text">
      <div class="title"></div>
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>

    </div>
  </div>

  <div class="section eight" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section nine" id="HowItWorks">
    <div class="box__text">
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section ten" id="reachus">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
    </div>
  </div>

</body>

</html>


<script id="fragmentShader" type="x-shader/x-fragment">


// ---------------------------------------------------- Settings

  #extension GL_OES_standard_derivatives : enable
  #ifdef GL_ES
  precision lowp float;
  #endif

  
  uniform sampler2D myTexture;
  varying vec2 texcoord;
  uniform vec2 iResolution;
  uniform float iTime;
  uniform vec2 iMousePos;
  vec2 mousePos = (iMousePos / iResolution.xy - .5)*0.3;
  uniform float iScrollProgress;
  uniform vec3 iAnimProgress_1;
  uniform vec3 iAnimProgress_2;
  uniform vec3 iAnimProgress_3;


#define PI          3.141592654
#define TAU         (2.0*PI)
#define SCA(a)      vec2(sin(a), cos(a))
#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))


// ---------------------------------------------------- Font
#define CHAR_SIZE vec2(6, 7)
#define CHAR_SPACING vec2(6, 9)

#define STRWIDTH(c) (c * CHAR_SPACING.x)
#define STRHEIGHT(c) (c * CHAR_SPACING.y)


vec2 ch_spc = vec2(0.0,0.0);
vec2 ch_exc = vec2(276705.0,32776.0);
vec2 ch_quo = vec2(1797408.0,0.0);
vec2 ch_hsh = vec2(10738.0,1134484.0);
vec2 ch_dol = vec2(538883.0,19976.0);
vec2 ch_pct = vec2(1664033.0,68006.0);
vec2 ch_amp = vec2(545090.0,174362.0);
vec2 ch_apo = vec2(798848.0,0.0);
vec2 ch_lbr = vec2(270466.0,66568.0);
vec2 ch_rbr = vec2(528449.0,33296.0);
vec2 ch_ast = vec2(10471.0,1688832.0);
vec2 ch_crs = vec2(4167.0,1606144.0);
vec2 ch_per = vec2(0.0,1560.0);
vec2 ch_dsh = vec2(7.0,1572864.0);
vec2 ch_com = vec2(0.0,1544.0);
vec2 ch_lsl = vec2(1057.0,67584.0);
vec2 ch_0 = vec2(935221.0,731292.0);
vec2 ch_1 = vec2(274497.0,33308.0);
vec2 ch_2 = vec2(934929.0,1116222.0);
vec2 ch_3 = vec2(934931.0,1058972.0);
vec2 ch_4 = vec2(137380.0,1302788.0);
vec2 ch_5 = vec2(2048263.0,1058972.0);
vec2 ch_6 = vec2(401671.0,1190044.0);
vec2 ch_7 = vec2(2032673.0,66576.0);
vec2 ch_8 = vec2(935187.0,1190044.0);
vec2 ch_9 = vec2(935187.0,1581336.0);
vec2 ch_col = vec2(195.0,1560.0);
vec2 ch_scl = vec2(195.0,1544.0);
vec2 ch_les = vec2(135300.0,66052.0);
vec2 ch_equ = vec2(496.0,3968.0);
vec2 ch_grt = vec2(528416.0,541200.0);
vec2 ch_que = vec2(934929.0,1081352.0);
vec2 ch_ats = vec2(935285.0,714780.0);
vec2 ch_A = vec2(935188.0,780450.0);
vec2 ch_B = vec2(1983767.0,1190076.0);
vec2 ch_C = vec2(935172.0,133276.0);
vec2 ch_D = vec2(1983764.0,665788.0);
vec2 ch_E = vec2(2048263.0,1181758.0);
vec2 ch_F = vec2(2048263.0,1181728.0);
vec2 ch_G = vec2(935173.0,1714334.0);
vec2 ch_H = vec2(1131799.0,1714338.0);
vec2 ch_I = vec2(921665.0,33308.0);
vec2 ch_J = vec2(66576.0,665756.0);
vec2 ch_K = vec2(1132870.0,166178.0);
vec2 ch_L = vec2(1065220.0,133182.0);
vec2 ch_M = vec2(1142100.0,665762.0);
vec2 ch_N = vec2(1140052.0,1714338.0);
vec2 ch_O = vec2(935188.0,665756.0);
vec2 ch_P = vec2(1983767.0,1181728.0);
vec2 ch_Q = vec2(935188.0,698650.0);
vec2 ch_R = vec2(1983767.0,1198242.0);
vec2 ch_S = vec2(935171.0,1058972.0);
vec2 ch_T = vec2(2035777.0,33288.0);
vec2 ch_U = vec2(1131796.0,665756.0);
vec2 ch_V = vec2(1131796.0,664840.0);
vec2 ch_W = vec2(1131861.0,699028.0);
vec2 ch_X = vec2(1131681.0,84130.0);
vec2 ch_Y = vec2(1131794.0,1081864.0);
vec2 ch_Z = vec2(1968194.0,133180.0);
vec2 ch_lsb = vec2(925826.0,66588.0);
vec2 ch_rsl = vec2(16513.0,16512.0);
vec2 ch_rsb = vec2(919584.0,1065244.0);
vec2 ch_pow = vec2(272656.0,0.0);
vec2 ch_usc = vec2(0.0,62.0);
vec2 ch_a = vec2(224.0,649374.0);
vec2 ch_b = vec2(1065444.0,665788.0);
vec2 ch_c = vec2(228.0,657564.0);
vec2 ch_d = vec2(66804.0,665758.0);
vec2 ch_e = vec2(228.0,772124.0);
vec2 ch_f = vec2(401543.0,1115152.0);
vec2 ch_g = vec2(244.0,665474.0);
vec2 ch_h = vec2(1065444.0,665762.0);
vec2 ch_i = vec2(262209.0,33292.0);
vec2 ch_j = vec2(131168.0,1066252.0);
vec2 ch_k = vec2(1065253.0,199204.0);
vec2 ch_l = vec2(266305.0,33292.0);
vec2 ch_m = vec2(421.0,698530.0);
vec2 ch_n = vec2(452.0,1198372.0);
vec2 ch_o = vec2(228.0,665756.0);
vec2 ch_p = vec2(484.0,667424.0);
vec2 ch_q = vec2(244.0,665474.0);
vec2 ch_r = vec2(354.0,590904.0);
vec2 ch_s = vec2(228.0,114844.0);
vec2 ch_t = vec2(8674.0,66824.0);
vec2 ch_u = vec2(292.0,1198868.0);
vec2 ch_v = vec2(276.0,664840.0);
vec2 ch_w = vec2(276.0,700308.0);
vec2 ch_x = vec2(292.0,1149220.0);
vec2 ch_y = vec2(292.0,1163824.0);
vec2 ch_z = vec2(480.0,1148988.0);
vec2 ch_lpa = vec2(401542.0,66572.0);
vec2 ch_bar = vec2(266304.0,33288.0);
vec2 ch_rpa = vec2(788512.0,1589528.0);
vec2 ch_tid = vec2(675840.0,0.0);
vec2 ch_lar = vec2(8387.0,1147904.0);
vec2 res;
//Extracts bit b from the given number.
//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).
float extract_bit(float n, float b)
{
    b = clamp(b,-1.0,22.0); //Fixes small artefacts on my nexus 7
	return floor(mod(floor(n / pow(2.0,floor(b))),2.0));   
}
//Returns the pixel at uv in the given bit-packed sprite.
float sprite(vec2 spr, vec2 size, vec2 uv)
{
    uv = floor(uv);
    //Calculate the bit to extract (x + y * width) (flipped on x-axis)
    float bit = (size.x-uv.x-1.0) + uv.y * size.x;
    
    //Clipping bound to remove garbage outside the sprite's boundaries.
    bool bounds = all(greaterThanEqual(uv,vec2(0)));
    bounds = bounds && all(lessThan(uv,size));
    
    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;
}
vec2 print_pos = vec2(0);
//Prints a character and moves the print position forward by 1 character width.
float char(vec2 ch, vec2 uv)
{
    float px = sprite(ch, CHAR_SIZE, uv - print_pos);
    print_pos.x += CHAR_SPACING.x;
    return px;
}
//Returns the digit sprite for the given number.
vec2 get_digit(float d)
{
    d = floor(d);
    if(d == 0.0) return ch_0;
    if(d == 1.0) return ch_1;
    if(d == 2.0) return ch_2;
    if(d == 3.0) return ch_3;
    if(d == 4.0) return ch_4;
    if(d == 5.0) return ch_5;
    if(d == 6.0) return ch_6;
    if(d == 7.0) return ch_7;
    if(d == 8.0) return ch_8;
    if(d == 9.0) return ch_9;
    return vec2(0.0);
}
//Prints out the given number starting at pos.
float print_number(float number,vec2 pos, vec2 uv)
{
	vec2 dec_pos = pos;
    float result = 0.0;
	for(int i = 3;i >= -2;i--)
    {
        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0); //Clip off leading zeros.
        float digit = mod(number / pow(10.0, float(i)),10.0);
        if(i == -1)
        {
            result += sprite(ch_per,CHAR_SIZE, uv - dec_pos) * clip;
            dec_pos.x += CHAR_SPACING.x * clip;
        }
        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;
        dec_pos.x += CHAR_SPACING.x * clip;
    }
    return result;
}


//BackGround ----------------------------------------------------

const vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
vec3 hsv2rgb(vec3 c) {
  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);
  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);
}

//Triangle calcs
float equilateralTriangle(vec2 p) {
  const float k = sqrt(3.0);
  p.x = abs(p.x) - 1.0;
  p.y = p.y + 1.0 / k;
  if(p.x + k * p.y > 0.0)
    p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;
  p.x -= clamp(p.x, -2.0, 0.0);
  return -length(p) * sign(p.y);
}



vec3 tradeTriRender(vec3 col, vec3 ro, vec3 rd) {
    // Triangle fill color
    vec3 fillColor = vec3(0.005, 0.0, 0.0);
    // triangle calcs
    const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
    float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
    vec3 pp = ro + rd * tpd;

  vec2 p2 = pp.xy;
  p2.x = -p2.x ;
  // triangle resize
  p2 *= 0.5;
  // triangle offset
  p2.y -= 0.58;
  p2.x += 0.002;
  p2.x -= 0.0 + iAnimProgress_3.y * 0.1 - iAnimProgress_3.z * 0.1;
  // triangle inner glow factor
  vec3 gcol2 = hsv2rgb(vec3(1.0,
   0.8-(iAnimProgress_1.x*0.4)+(iAnimProgress_3.x*0.4),
   0.006-iAnimProgress_1.x*0.0035-iAnimProgress_1.y*0.0015+iAnimProgress_1.z*0.0015));
  // triangle displacement
  float dt2 = equilateralTriangle(p2);
  // Smooth the cut edge of the triangle
  if (p2.x > 0.0) {
    // Left half of the triangle
    vec3 leftHalfColor = dt2 < 0.0 ? fillColor : col;
    leftHalfColor += (gcol2 / max(abs(dt2), 0.001)) * smoothstep(0.5, 0.0, dt2);

    // Right half of the triangle (unchanged)
    col = col;

    // Blend the two halves together
    float blendFactor2 = smoothstep(0.0, 0.003, p2.x); // Adjust the blend factor as needed
    col = mix(col, leftHalfColor, blendFactor2);
}

    vec2 p = pp.xy;
    p.x = -p.x ;

    // triangle resize
    p *= 0.5;
    // triangle y offset
    p.y -= 0.58;
    p.x -= 0.002;

    p.x += 0.0+iAnimProgress_3.y*0.08-iAnimProgress_3.z*0.08;

     // triangle inner glow factor
    vec3 gcol = hsv2rgb(vec3(1.0,
    0.8-(iAnimProgress_1.x*0.4)+(iAnimProgress_3.x*0.4),
    0.006-iAnimProgress_1.x*0.0035-iAnimProgress_1.y*0.0015+iAnimProgress_1.z*0.0015));
   // triangle displacement
    float dt = equilateralTriangle(p);
    
    // Split the triangle by adding a condition based on the y-coordinate of the point.
    // Smooth the right half of the triangle
    if (p.x < 0.0) {
      // Right half of the triangle
      vec3 rightHalfColor = dt < 0.0 ? fillColor : col;
      rightHalfColor += (gcol / max(abs(dt), 0.001)) * smoothstep(0.5, 0.0, dt);

      // Blend the two halves together
      float blendFactor = smoothstep(0.0, 0.003, -p.x); // Adjust the blend factor as needed
      col = mix(col, rightHalfColor, blendFactor);
  }

  print_pos -= print_pos;
  print_pos -= vec2(32.0,-34.0);
  float colT;
  float ScaleT = 95.0;
  colT += char(ch_I,p*ScaleT);
  colT += char(ch_N,p*ScaleT);
  colT += char(ch_T,p*ScaleT);
  colT += char(ch_E,p*ScaleT);
  colT += char(ch_N,p*ScaleT);
  colT += char(ch_T,p*ScaleT);
  colT += char(ch_spc,p*ScaleT);
  colT += char(ch_P,p*ScaleT);
  colT += char(ch_O,p*ScaleT);
  colT += char(ch_O,p*ScaleT);
  colT += char(ch_L,p*ScaleT);
  col = mix(col,vec3(3.0,2.0,2.0),colT*(iAnimProgress_1.x-(iAnimProgress_1.y*0.8)+(iAnimProgress_1.z*0.8)-iAnimProgress_3.x));

  print_pos -= print_pos;
  print_pos -= vec2(20.0,-3.0);
  float tradeTextCol;
  float ScaleS = 65.0;
  tradeTextCol += char(ch_E,p*ScaleS);
  tradeTextCol += char(ch_X,p*ScaleS);
  tradeTextCol += char(ch_E,p*ScaleS);
  tradeTextCol += char(ch_C,p*ScaleS);
  tradeTextCol += char(ch_U,p*ScaleS);
  tradeTextCol += char(ch_T,p*ScaleS);
  tradeTextCol += char(ch_E,p*ScaleS);
  col = mix(col,vec3(3.0,2.0,2.0),iAnimProgress_2.y*tradeTextCol*(iAnimProgress_2.z-iAnimProgress_3.x)*(sin((iAnimProgress_2.z)*3.5)));



    return col;
}

vec3 triRender_left(vec3 col, vec3 ro, vec3 rd) {
  // Triangle fill color
  vec3 fillColor = vec3(0.009, 0.0, 0.0);
  // triangle calcs
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy;
  // triangle resize
  p *= 1.0;
  // triangle offset
  p.y -= 0.58;
  p.x -= 1.0 + iAnimProgress_1.x * 1.00 - iAnimProgress_1.z * 1.0;
  // triangle inner glow factor
  p.x = -p.x;
  vec3 gcol = hsv2rgb(vec3(1.0, 0.8, 0.006));
  // triangle displacement
  float dt = equilateralTriangle(p);
  // Triangle visibility parameter
  float visibility = 1.0-(iAnimProgress_1.x*0.9)+(iAnimProgress_3.x*0.9);
  if (dt < 0.0) {col = mix(fillColor, col, visibility);}
  // triangle edge glow mod
  col += (gcol / max(abs(dt), 0.001)) * smoothstep(0.5, 0.0, dt) * (iAnimProgress_1.x*1.0-iAnimProgress_3.x*1.0);

  print_pos -= print_pos;
  print_pos -= vec2(23.0-(iAnimProgress_2.z*100.0),8.0);
  float colIntentA;
  float ScaleIntentA = 50.0;
  colIntentA += char(ch_I,p*ScaleIntentA);
  colIntentA += char(ch_N,p*ScaleIntentA);
  colIntentA += char(ch_T,p*ScaleIntentA);
  colIntentA += char(ch_E,p*ScaleIntentA);
  colIntentA += char(ch_N,p*ScaleIntentA);
  colIntentA += char(ch_T,p*ScaleIntentA);
  colIntentA += char(ch_spc,p*ScaleIntentA);
  colIntentA += char(ch_A,p*ScaleIntentA);
  col = mix(col,vec3(3.0,1.0,1.0),colIntentA*(iAnimProgress_1.y-iAnimProgress_2.z));

  print_pos -= print_pos;
  print_pos -= vec2(10.0,20.0);
  float colYOU;
  float ScaleT = 50.0;
  colYOU += char(ch_Y,p*ScaleT);
  colYOU += char(ch_O,p*ScaleT);
  colYOU += char(ch_U,p*ScaleT);
  col = mix(col,vec3(3.0,1.0,1.0),colYOU*(iAnimProgress_1.x-iAnimProgress_1.z));

  print_pos -= print_pos;
  print_pos -= vec2(21.0,20.0);
  float col2;
  float ScaleZ = 50.0;
  col2 += char(ch_P,p*ScaleZ);
  col2 += char(ch_A,p*ScaleZ);
  col2 += char(ch_R,p*ScaleZ);
  col2 += char(ch_T,p*ScaleZ);
  col2 += char(ch_Y,p*ScaleZ);
  col2 += char(ch_spc,p*ScaleZ);
  col2 += char(ch_A,p*ScaleZ);
  col = mix(col,vec3(3.0,1.0,1.0),col2*(iAnimProgress_1.z-iAnimProgress_3.z));

  print_pos -= print_pos;
  print_pos -= vec2(15.0-(iAnimProgress_2.z*100.0),8.0);
  float colIntentB;
  float ScaleIntentB = 60.0;
  
  colIntentB += char(ch_crs,p*ScaleIntentB);
  colIntentB += char(ch_1,p*ScaleIntentB);
  colIntentB += char(ch_spc,p*ScaleIntentB);
  colIntentB += char(ch_B,p*ScaleIntentB);
  colIntentB += char(ch_T,p*ScaleIntentB);
  colIntentB += char(ch_C,p*ScaleIntentB);
  colIntentB += char(ch_spc,p*ScaleIntentB);
  colIntentB += char(ch_S,p*ScaleIntentB);
  colIntentB += char(ch_H,p*ScaleIntentB);
  colIntentB += char(ch_O,p*ScaleIntentB);
  colIntentB += char(ch_R,p*ScaleIntentB);
  colIntentB += char(ch_T,p*ScaleIntentB);

  col = mix(col,vec3(3.0,1.0,1.0),colIntentB*(iAnimProgress_2.z-iAnimProgress_3.x));

  return col;
}

vec3 triRender_right(vec3 col, vec3 ro, vec3 rd) {
  // Triangle fill color
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  // Triangle calcs
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy;
  // Triangle resize
  p *= 1.0;
  // Triangle y offset
  p.y -= 0.58;
  p.x += 2.0-iAnimProgress_2.y;
  p.x = -p.x;
  // Triangle inner glow factor
  vec3 gcol = hsv2rgb(vec3(1.0, 0.9-(iAnimProgress_3.x*0.1), 0.006));
  // Triangle displacement
  float dt = equilateralTriangle(p);
  // Triangle visibility parameter
  float visibility = 1.0-(iAnimProgress_1.x*0.9)+(iAnimProgress_2.z*0.9);
  if (dt < 0.0) {col = mix(fillColor, col, visibility);}

  // triangle edge glow mod
  col += (gcol / max(abs(dt), 0.001)) * smoothstep(0.5, 0.0, dt) * ((iAnimProgress_1.x*1.0)- (iAnimProgress_1.y*0.8)+ (iAnimProgress_2.y*1.0) - (iAnimProgress_3 .x*1.2));
  
  print_pos -= print_pos;
  print_pos -= vec2(55.0+(iAnimProgress_2.z*100.0),8.0);
  float colCVAA;
  float scaleCVAA = 60.0;
  
  colCVAA += char(ch_crs,p*scaleCVAA);
  colCVAA += char(ch_1,p*scaleCVAA);
  colCVAA += char(ch_spc,p*scaleCVAA);
  colCVAA += char(ch_B,p*scaleCVAA);
  colCVAA += char(ch_T,p*scaleCVAA);
  colCVAA += char(ch_C,p*scaleCVAA);
  colCVAA += char(ch_spc,p*scaleCVAA);
  colCVAA += char(ch_L,p*scaleCVAA);
  colCVAA += char(ch_O,p*scaleCVAA);
  colCVAA += char(ch_N,p*scaleCVAA);
  colCVAA += char(ch_G,p*scaleCVAA);

  col = mix(col,vec3(3.0,0.3,0.3),colCVAA*(iAnimProgress_2.z-iAnimProgress_3.x));
  
    
  print_pos -= print_pos;
  print_pos -= vec2(23.0+(iAnimProgress_2.z*100.0),8.0);
  float colIntentB;
  float scalecolIntentB = 50.0;
  colIntentB += char(ch_I,p*scalecolIntentB);
  colIntentB += char(ch_N,p*scalecolIntentB);
  colIntentB += char(ch_T,p*scalecolIntentB);
  colIntentB += char(ch_E,p*scalecolIntentB);
  colIntentB += char(ch_N,p*scalecolIntentB);
  colIntentB += char(ch_T,p*scalecolIntentB);
  colIntentB += char(ch_spc,p*scalecolIntentB);
  colIntentB += char(ch_B,p*scalecolIntentB);

  col = mix(col,vec3(3.0,0.3,0.3),colIntentB*(iAnimProgress_2.x-iAnimProgress_2.z));
  

  print_pos -= print_pos;
  print_pos -= vec2(18.0,20.0);
  float colT;
  float ScaleT = 50.0;
  colT += char(ch_H,p*ScaleT);
  colT += char(ch_E,p*ScaleT);
  colT += char(ch_D,p*ScaleT);
  colT += char(ch_G,p*ScaleT);
  colT += char(ch_E,p*ScaleT);
  colT += char(ch_R,p*ScaleT);
  col = mix(col,vec3(3.0,0.3,0.3),colT*(iAnimProgress_1.x- (iAnimProgress_1.y*0.7)+ (iAnimProgress_2.x*0.7)-iAnimProgress_2.y));
  
  print_pos -= print_pos;
  print_pos -= vec2(20.0,20.0);
  float col2;
  float ScaleZ = 50.0;
  col2 += char(ch_P,p*ScaleZ);
  col2 += char(ch_A,p*ScaleZ);
  col2 += char(ch_R,p*ScaleZ);
  col2 += char(ch_T,p*ScaleZ);
  col2 += char(ch_Y,p*ScaleZ);
  col2 += char(ch_spc,p*ScaleZ);
  col2 += char(ch_B,p*ScaleZ);
  col = mix(col,vec3(3.0,0.3,0.3),col2*(iAnimProgress_2.y-iAnimProgress_3.z));
 
  return col;
}

vec3 renderTriangle(vec3 col, vec3 ro, vec3 rd, float scaleFactor, float xOffset) {
  // Triangle fill color
  vec3 fillColor = vec3(0.009, 0.0, 0.0);
  // Triangle dimensions
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  // Calculate intersection with the triangle
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec2 p = pp.xy;
  // Resize and offset the triangle
  p *= scaleFactor;
  p.x += xOffset;
  p.y -= 0.58;
  p.x += 1.0 + iAnimProgress_1.x * 1.0;
  float a;

  // Triangle inner glow factor
  vec3 gcol = hsv2rgb(vec3(1.0, 0.9 - (iAnimProgress_3.x * 0.1), 0.006));
  // Calculate triangle displacement
  float dt = equilateralTriangle(p);
  // Triangle visibility parameter
  float visibility = 1.0 - (iAnimProgress_1.x * scaleFactor * 0.2) + (iAnimProgress_1.y * scaleFactor * 0.1) + (iAnimProgress_2.y * scaleFactor * 0.1);
  if (dt < 0.0) {
    col = mix(fillColor, col, visibility);
  }
  // Triangle edge glow mod
  col += (gcol / max(abs(dt), 0.001)) * smoothstep(0.5, 0.0, dt) * ((iAnimProgress_1.x * scaleFactor * 0.1) - (iAnimProgress_1.y * scaleFactor * 0.05) - (iAnimProgress_2.y * scaleFactor * 0.05));
  return col;
}

vec3 triRender_right_4(vec3 col, vec3 ro, vec3 rd) {
  return renderTriangle(col, ro, rd, 1.25, 1.22);
}

vec3 triRender_right_3(vec3 col, vec3 ro, vec3 rd) {
  return renderTriangle(col, ro, rd, 1.16, 0.8);
}

vec3 triRender_right_2(vec3 col, vec3 ro, vec3 rd) {
  return renderTriangle(col, ro, rd, 1.08, 0.4);
}

vec3 eyeRender(vec3 col, vec2 p, float vis)
{
    // Calculate blink
    float eyeBlink = smoothstep(-0.28, 0.2, mod(iTime, 0.0));
    eyeBlink -= smoothstep(0.28, 0.4, mod(iTime, 2.5));
    // REPLACEMENT
    vec2 rotatedP = vec2(-p.y + 0.2, p.x);
    // Calculate Almond Eye
    float bl = 1.0 ;
    bl*=vis;
    float k = -clamp(bl * bl, 0.06, 1.0);
    vec2 pos = vec2(-4.0 * rotatedP.y, 4.0 * rotatedP.x);
    pos = abs(pos);
    float ik = 1.0 / k;
    float parabola_p = ik * (pos.y - 1.1 * ik) / 3.0;
    float parabola_q = 0.25 * ik * ik * pos.x;
    float parabola_h = parabola_q * parabola_q - parabola_p * parabola_p * parabola_p;
    float parabola_r = sqrt(abs(parabola_h));
    float parabola_x = (parabola_h > 0.0) ?
        pow(parabola_q + parabola_r, 1.0 / 3.0) - pow(abs(parabola_q - parabola_r), 1.0 / 3.0) * sign(parabola_r - parabola_q) :
        2.0 * cos(atan(parabola_r, parabola_q) / 3.0) * sqrt(parabola_p);

    float sdEye = length(pos - vec2(parabola_x, k * parabola_x * parabola_x)) * sign(pos.x - parabola_x) - bl + 0.06;

    // Apply smoothstep to color using sdEye
    col += smoothstep(0.015, 0.025, abs(sdEye));
    // Eye core creation and reposition
    vec2 adjustedMousePos = vec2(-mousePos.y,1.1*(mousePos.x-0.07)) * 2.0;
    vec2 diff = 2.0 * rotatedP - adjustedMousePos;
    float distance = length(diff) - 0.3 - 2.0 * smoothstep(0.895, 0.9, 0.0);
    float eyeMask = max(distance, sdEye);
    col = min(col, smoothstep(-0.01, 0.0, eyeMask * vis));
    return col;
}

vec3 triRender_Liquidator(vec3 col, vec3 ro, vec3 rd,vec2 p) {
  // Triangle fill color
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  float isleftHalf;
  // Triangle calcs
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec3 triColor;
  vec3 eyeColor;
    //...................Triangle Static
    vec2 pTriStatic = pp.xy;
    pTriStatic.x = -pTriStatic.x ;
    // triangle resize
    pTriStatic *= 0.5;
    // triangle y offset
    pTriStatic.y -= 0.58;
    pTriStatic.x -= 0.0001;
    pTriStatic.x += 0.0;
    // triangle displacement
    float dtS = equilateralTriangle(pTriStatic);
    
    for (int i = 1; i <= 6; i++) {
    //...................Triangle Liquidators

    vec2 p = pp.xy;
    // Circular motion parameters
    float speed = float(i);
    float angle = (iTime* (8.0 / 8.0) ) + speed; // 240 degrees rotation

    float tradeAnim = (sin(angle) + 1.0) / 2.0;

    // Triangle y offset
    p.y -= 3.8;
    
    float calSin = sin(angle); 
    float calCos = cos(angle); 
    float fadeSpeed = 1.0;
    
    if (calCos > 0.0) {
      p.x += calCos * 2.5;
      p.y += calSin * 1.5;
      p *= 0.5 + (tradeAnim / 2.0);
      isleftHalf = 0.0;
      if (speed == 1.0) {
        triColor = vec3(1.0, 0.1,0.006);
        eyeColor = vec3(1.5,1.5,1.5);
      } else {
        triColor = vec3(1.0, 0.1,0.006);
        eyeColor = vec3(1.5,1.5,1.5);
      }
    } else {
      p.x += 0.0;
      p.y += 1.5;
      tradeAnim = 1.0;
      tradeAnim = max((sin(angle)*10.0)-9.0,0.0) ;
      isleftHalf = 1.0;
      if (speed == 1.0) {

        triColor = vec3(1.0, 0.9,0.006);
        eyeColor = vec3(3.5,0.5,0.5);
      } else {
        triColor = vec3(1.0, 0.1,0.006);
        eyeColor = vec3(1.5,1.5,1.5);
      }
    }
    
    // Invert Triangle 
    p.x = -p.x;
    
    // Triangle displacement
    float dt = equilateralTriangle(p);
    
    //...Text Liquidators
    print_pos -= print_pos;
    print_pos -= vec2(30.0, 15.0);
    float charCol;
    float Scale = 50.0;
    charCol += char(ch_L, p * Scale);
    charCol += char(ch_I, p * Scale);
    charCol += char(ch_Q, p * Scale);
    charCol += char(ch_U, p * Scale);
    charCol += char(ch_I, p * Scale);
    charCol += char(ch_D, p * Scale);
    charCol += char(ch_A, p * Scale);
    charCol += char(ch_T, p * Scale);
    charCol += char(ch_O, p * Scale);
    charCol += char(ch_R, p * Scale);

    float staticTextColSolve;
    float ScaleS = 65.0;
    float staticTextCol;
    if (speed == 1.0){
        //...Text Liquidate party
        print_pos -= print_pos;
        print_pos -= vec2(39.0,28.0);
        float ScaleLiquidParty = 55.0;
        staticTextCol += char(ch_dsh,pTriStatic*ScaleLiquidParty);
        staticTextCol += char(ch_dsh,pTriStatic*ScaleLiquidParty);
        staticTextCol += char(ch_dsh,pTriStatic*ScaleLiquidParty);
        staticTextCol += char(ch_dsh,pTriStatic*ScaleLiquidParty);
                //...Text Liquidate party number
        print_pos -= print_pos;
        print_pos -= vec2(55.0,27.0*tradeAnim);
        float ScaleLiquidPartyNum = 85.0;
        staticTextCol += char(ch_dsh,pTriStatic*ScaleLiquidPartyNum);
        staticTextCol += char(ch_dol,pTriStatic*ScaleLiquidPartyNum);
        staticTextCol += char(ch_1,pTriStatic*ScaleLiquidPartyNum);
        staticTextCol += char(ch_B,pTriStatic*ScaleLiquidPartyNum);
        staticTextCol += char(ch_T,pTriStatic*ScaleLiquidPartyNum);
        staticTextCol += char(ch_C,pTriStatic*ScaleLiquidPartyNum);


        //...Text Liquidate
        print_pos -= print_pos;
        print_pos -= vec2(27.0,-3.0);
        staticTextCol += char(ch_L,pTriStatic*ScaleS);
        staticTextCol += char(ch_I,pTriStatic*ScaleS);
        staticTextCol += char(ch_Q,pTriStatic*ScaleS);
        staticTextCol += char(ch_U,pTriStatic*ScaleS);
        staticTextCol += char(ch_I,pTriStatic*ScaleS);
        staticTextCol += char(ch_D,pTriStatic*ScaleS);
        staticTextCol += char(ch_A,pTriStatic*ScaleS);
        staticTextCol += char(ch_T,pTriStatic*ScaleS);
        staticTextCol += char(ch_E,pTriStatic*ScaleS);
    }else{
      //...Text Solvent
      print_pos -= print_pos;
      print_pos -= vec2(20.0,-3.0);
      staticTextColSolve += char(ch_S,pTriStatic*ScaleS);
      staticTextColSolve += char(ch_O,pTriStatic*ScaleS);
      staticTextColSolve += char(ch_L,pTriStatic*ScaleS);
      staticTextColSolve += char(ch_V,pTriStatic*ScaleS);
      staticTextColSolve += char(ch_E,pTriStatic*ScaleS);
      staticTextColSolve += char(ch_N,pTriStatic*ScaleS);
      staticTextColSolve += char(ch_T,pTriStatic*ScaleS);
    }

    float vis = max(tradeAnim*(iAnimProgress_3.x-iAnimProgress_3.y),0.0);
    // Triangle visibility parameter
    if (dt < 0.0) {
      col = mix(fillColor, col, 1.0 - vis);
    }

    // Triangle liquidator glow color
    vec3 tricol = hsv2rgb(triColor);

    // Triangle static trade  glow factor
    vec3 gcolS = hsv2rgb(triColor);

    //add triangle static to col
    col += (gcolS / max(abs(dtS), 0.001)) * smoothstep(0.5, 0.0, dtS)*isleftHalf* vis/2.0;

    // add triangle liquidators to col
    col += (tricol / max(abs(dt), 0.001)) * smoothstep(0.5, 0.0, dt) * vis;
    //add text Liquidator to col
    col = mix(col,eyeColor,charCol* vis);

    //add text static to col
    col += staticTextColSolve*isleftHalf* vis;

    //add text liquidate to col
    col = mix(col,vec3(3.0,0.3,0.3),staticTextCol*isleftHalf* vis);

    // add eye to col
    col = mix(vis* iAnimProgress_3.x*(eyeColor),col,eyeRender(col,p,vis));


  }
  
  return col;
}


//-----Outer Sky

//sun dir right-left , up-down , back forth
vec3 sunDir = normalize(vec3(-mousePos.x*4.0,-2.0+ (mousePos.y*2.0)+iAnimProgress_3.x*0.0-iAnimProgress_3.z*4.0, 20.0));
const vec3 sunCol = HSV2RGB(vec3(0.00, 0.7, 0.002));

vec3 outerSkyRender(vec3 ro, vec3 rd) {
  vec3 col;
  //sun settings
  col += sunCol / pow((1.002 - ((dot(sunDir, rd)))), 1.9-iAnimProgress_1.x+iAnimProgress_3.x*0.5+iAnimProgress_3.y*0.5);
  //horizon light modifier
  vec3 gcol = hsv2rgb(vec3(1.0, 0.0, 0.002 - iAnimProgress_1.x * 0.0018 + iAnimProgress_3.y * 0.004));
  gcol = mix(gcol, vec3(0.0), smoothstep(0.5, 1.0, abs(rd.y)));
  //atmosphere air color
  col += hsv2rgb(vec3(0.07, 0., 0.1));
  col += gcol / max(abs(rd.y), 0.0);
  return col;
}
//-----Ground
vec3 groundRender(vec3 col, vec3 ro, vec3 rd) {
  const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));
  float gpd = -(dot(ro, vec4(gpn, 0.0).xyz) + vec4(gpn, 0.0).w) / dot(rd, vec4(gpn, 0.0).xyz);
  if(gpd < 1.0) {
    return col;
  }
  // Tiles reflection mod
  vec3 gp = ro + rd * gpd;
  float gpfre = pow(1.15 + dot(rd, gpn), 4.0);
    gpfre *= gpfre;
  gpfre *= gpfre;

  // Calculate reflected ray
  vec3 grr = reflect(rd, gpn);
  // Calculate ggp and its properties
  vec2 ggp = gp.xz + vec2(0.0, iTime); // Only modify the time component
  float dfy = dFdy(ggp.y);
  float gcf = sin(ggp.x) * sin(ggp.y);
  // mod calculations
  vec2 size = vec2(1.0);
  vec2 c = floor((ggp));
  ggp = mod(ggp + size * 0.5, size) - size * 0.5;
  float ggd = min(abs(ggp.x), abs(ggp.y));
  // Tiles lines color modifier
  vec3 gcol = hsv2rgb(vec3(0.01 * gcf, 0.7, 0.005));
  // Calculate reflections
  
  vec3 rcol = outerSkyRender(grr,grr);
  rcol = tradeTriRender(rcol, gp, grr);
  rcol = triRender_left(rcol, gp, grr);
  rcol = triRender_right(rcol, gp, grr);

  //ground horizon reflection color filter
  rcol += hsv2rgb(vec3(1.0, 0.2, 0.2)) ;
  
//tiles calcs
  col = gcol / max(ggd, 0.25 * dfy) * exp((-0.5-1.0*(iAnimProgress_1.x*0.5-iAnimProgress_3.x*0.5 ))* gpd);
  //ground horizon reflection color filter
  rcol += hsv2rgb(vec3(0.0, 0.0, 0.0)) ;
  //ground reflection factor
  col += rcol * gpfre/(9.0+(iAnimProgress_1.x*9.0)-iAnimProgress_3.x*0.0);

  
  return col;
}

//effects control
vec3 aces_approx(vec3 v) {
  v = max(v, 0.0);
  v *= 0.2;
  //scene effects variables
  float a = 2.0;
  float b = 0.09;
  float c = 0.43;
  float d = 0.59;
  float e = 0.24;
  return clamp((v * (a * v + b)) / (v * (c * v + d) + e), 0.0, 1.0);
}

vec3 sRGB(vec3 p) {
  return mix(1.055 * pow(p, vec3(1. / 2.4)) - 0.055, 12.92 * p, step(p, vec3(0.0031308)));
} 
vec3 render(vec3 ro, vec3 rd, vec2 p) {

  vec3 col = outerSkyRender(rd,rd);
  col = groundRender(col, ro, rd);
  col = tradeTriRender(col, ro, rd);
  col = triRender_left(col, ro, rd);
  col = triRender_right_4(col, ro, rd);
  col = triRender_right_3(col, ro, rd);
  col = triRender_right_2(col, ro, rd);
  col = triRender_right(col, ro, rd);
  col = triRender_Liquidator(col, ro, rd,p);

  return col;
}

vec3 effect(vec2 p) {
  const float fov = tan(TAU / 6.0);
  float mobileMode;
  
float mobileRes = iResolution.x/iResolution.y;
if (mobileRes<1.1){
  mobileMode = 1.0;
}else{
  mobileMode = 0.0;
}
vec3 ro;
if (mobileMode== 0.0){

  //-------------camera location 
   ro = 1.0 * vec3(
    //right-left,
    iAnimProgress_1.x*1.8+iAnimProgress_3.x*0.9-iAnimProgress_3.z*1.4,
    //up-down,
    0.5+iAnimProgress_1.x*0.25-(iAnimProgress_3.x*0.0)-iAnimProgress_3.y*0.3,
    //front-back
    -5.0+(iAnimProgress_1.x*2.0)+iAnimProgress_3.z*3.5
  );
}else{
   ro = 1.0 * vec3(
    //right-left,
    0.0,
    //up-down,
    0.5+iAnimProgress_1.x*0.25-(iAnimProgress_3.x*0.0)-iAnimProgress_3.y*0.3,
    //front-back
    -12.0+(iAnimProgress_1.x*2.0)+iAnimProgress_3.z*9.5+iAnimProgress_3.y*2.5
  );
}

  //camera look at right-left,up-down,front-back
vec3 la;
if (mobileMode== 0.0){
  la = vec3(
    //right-left,
    0.0-(iAnimProgress_3.x*40.0),
    //up-down,
    225.0,
    //front-back
    1000.0);
}else{
  la = vec3(
    //right-left,
    0.0,
    //up-down,
    225.0+(iAnimProgress_3.x*100.0)-(iAnimProgress_3.z*240.0),
    //front-back
    1000.0);
}
  //camera rotation x-y-z
  vec3 up = vec3(0.0, 1.0, 0.0);
  
  vec3 ww = normalize(la - ro);
  vec3 uu = normalize(cross(up, ww));
  vec3 vv = cross(ww, uu);
  vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);
  vec3 col = render(ro, rd,p);
  col = aces_approx(col);
  col = sRGB(col);

  return col;
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  vec2 p = -1. + (2. * fragCoord / iResolution.xy);
  p.x *= iResolution.x / iResolution.y;
  vec3 col = effect(p);
  fragColor = vec4(col, 1.0);
}
  void main() {
    mainImage(gl_FragColor, gl_FragCoord.xy);
  }
</script>

<script src="threeJsHome.js"></script>