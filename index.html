<html lang="en">

<header>
  <title>SYMMIO</title>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-4bw+/aepP/YC94hEpVNVgiZdgIC5+VKNBQNGCHeKRQN+PtmoHDEXuppvnDJzQIu9" crossorigin="anonymous">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="./jQuerySet.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
  
  <script src="https://unpkg.com/gsap@3.5.1/dist/ScrollTrigger.min.js"></script>
  <script src="https://unpkg.com/gsap@3.5.1/dist/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.4.0/TextPlugin.min.js"></script>
  <script src="./gsapText.js"></script>

  <link rel="stylesheet" href="styleHome.css">
  <link rel="stylesheet" href="navbar.css">

  <nav>
    <ul class="menu__list">
      <li class="menu__item">
        <button class="menu__link" href="#Home">Home</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#HowItWorks">How it works</button>
      </li>
      <li class="menu__item">
        <button class="menu__link" href="#reachus">learn more</button>
      </li>
      <li><button class="reset">Trade</button>
      </li>
    </ul>
  </nav>


</header>

<body>

  <div id="webgl-container"></div>

  <input type="checkbox" id="menu_trigger" class="menu-trigger">
  <div class="overlay">
    <ul class="menu-links">
      <li><a id="link" href="#Home">Home</a></li>
      <li><a id="link" href="#HowItWorks">How it works</a></li>
      <li><a id="link" href="#reachus">learn more</a></li>
      <li><a id="link" class="red" href="#">TRADE</a></li>
    </ul>
  </div>
  <label for="menu_trigger" class="hamburger-menu">
    <span></span>
    <span></span>
    <span></span>
  </label>

  <script>
    // --------------Hambergur menu script
    const menuTrigger = document.querySelector('.menu-trigger');
    const overlay = document.querySelector('.overlay');

    // Get references to all menu links
    const menuLinks = document.querySelectorAll('.menu-links li a');

    // Add a click event listener to each menu link
    menuLinks.forEach(link => {
      link.addEventListener('click', () => {
        // Hide the overlay
        if (menuTrigger.checked = true) {
          menuTrigger.checked = false;
        }
      });
    });
  </script>

  <div class="section one " id="Home">
    <a class="scrollDown">
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="chevron"></span>
      <span class="text">[ more ]</span>
    </a>

    <div class="caption ">
      A protocol for SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>
    <div class="captionMobile ">
      <span class="first-line">A protocol for</span><br>
      SYMMETRICAL
      <div class="text-box">
        <div>CRYPTOS</div>
        <div>COMMODITIES</div>
        <div>AGREEMENTS</div>
        <div>FUTURES</div>
        <div>TRADING</div>
        <div>OPTIONS</div>
        <div>DERIVATIVES</div>
        <div>PERPETUALS</div>
        <div>BONDS</div>
        <div>STOCKS</div>
      </div>
    </div>

    <div class="box__text">

      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section two" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section three" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section four" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="subtitle"></div>
      <div class="title"></div>
    </div>
  </div>

  <div class="section five" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="title"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section six" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="title"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
    </div>
  </div>

  <div class="section seven" id="HowItWorks">
    <div class="box__text">
      <div class="title"></div>
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>

    </div>
  </div>

  <div class="section eight" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="titleSYMM "></div>
      <div class="title gradiant"></div>
      <div class="subtitle"></div>
    </div>
  </div>

  <div class="section nine" id="HowItWorks">
    <div class="box__text">
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
      <div class="list_top"></div>
    </div>
  </div>

  <div class="section ten" id="HowItWorks">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
    </div>
  </div>

  <div class="section eleven" id="reachus">
    <div class="box__text">
      <div class="list_top"></div>
      <div class="subtitle"></div>
      <div class="titleSYMM "></div>
      <div class="title"></div>
    </div>
  </div>

</body>

</html>


<script id="fragmentShader" type="x-shader/x-fragment">


  #extension GL_OES_standard_derivatives : enable

  uniform sampler2D myTexture;
  varying vec2 texcoord;
  uniform vec2 iResolution;
  uniform float iTime;
  uniform vec3 iAnimProgress_1;
  uniform vec3 iAnimProgress_2;
  uniform vec3 iAnimProgress_3;
  uniform vec3 iAnimProgress_4;
  #ifdef GL_ES
  precision lowp float;
  #endif





  const ivec2 char_space = ivec2(0, 0);
  const ivec2 char_exclam = ivec2(-2147352576, 135274560);
  const ivec2 char_quotedbl = ivec2(0, 338186240);
  const ivec2 char_numbersign = ivec2(-494600192, 338229411);
  const ivec2 char_dollar = ivec2(-2058944512, 475277538);
  const ivec2 char_percent = ivec2(1179385856, 105660480);
  const ivec2 char_ampersand = ivec2(-1572143104, 68429858);
  const ivec2 char_quoteright = ivec2(0, 135270400);
  const ivec2 char_parenleft = ivec2(1090781184, 269488160);
  const ivec2 char_parenright = ivec2(16842752, 68173953);
  const ivec2 char_asterisk = ivec2(-985530368, 139751489);
  const ivec2 char_plus = ivec2(-2130706432, 1057264);
  const ivec2 char_comma = ivec2(16908800, 0);
  const ivec2 char_hyphen = ivec2(0, 224);
  const ivec2 char_period = ivec2(131072, 0);
  const ivec2 char_slash = ivec2(1077936128, 4210752);
  const ivec2 char_zero = ivec2(578945024, 136874258);
  const ivec2 char_one = ivec2(-2130247680, 135798848);
  const ivec2 char_two = ivec2(1078951936, 474251456);
  const ivec2 char_three = ivec2(71761920, 1044398274);
  const ivec2 char_four = ivec2(-503054336, 271601811);
  const ivec2 char_five = ivec2(71761920, 1040480514);
  const ivec2 char_six = ivec2(608632832, 403179762);
  const ivec2 char_seven = ivec2(1082195968, 1044398144);
  const ivec2 char_eight = ivec2(608632832, 474253538);
  const ivec2 char_nine = ivec2(33751040, 474253794);
  const ivec2 char_colon = ivec2(131072, 8192);
  const ivec2 char_semicolon = ivec2(16908800, 8192);
  const ivec2 char_less = ivec2(1090781184, 269488144);
  const ivec2 char_equal = ivec2(-536870912, 63491);
  const ivec2 char_greater = ivec2(16842752, 68174081);
  const ivec2 char_question = ivec2(-2147352576, 474234944);
  const ivec2 char_at = ivec2(-1605959680, 474278227);
  const ivec2 char_A = ivec2(-465010688, 136874259);
  const ivec2 char_B = ivec2(608665600, 507807986);
  const ivec2 char_C = ivec2(608632832, 474220560);
  const ivec2 char_D = ivec2(608665600, 507808018);
  const ivec2 char_E = ivec2(542081024, 1040451824);
  const ivec2 char_F = ivec2(541097984, 1040451824);
  const ivec2 char_G = ivec2(609157120, 474220563);
  const ivec2 char_H = ivec2(608731136, 574917106);
  const ivec2 char_I = ivec2(-2130247680, 470818880);
  const ivec2 char_J = ivec2(71761920, 541098242);
  const ivec2 char_K = ivec2(-1572306944, 572794928);
  const ivec2 char_L = ivec2(542081024, 33818640);
  const ivec2 char_M = ivec2(608731136, 577546578);
  const ivec2 char_N = ivec2(608731136, 574921043);
  const ivec2 char_O = ivec2(608632832, 474253586);
  const ivec2 char_P = ivec2(541097984, 507807984);
  const ivec2 char_Q = ivec2(-1572143104, 474253586);
  const ivec2 char_R = ivec2(-1572306944, 507807984);
  const ivec2 char_S = ivec2(71761920, 474220770);
  const ivec2 char_T = ivec2(-2130575360, 1041244224);
  const ivec2 char_U = ivec2(608632832, 574916882);
  const ivec2 char_V = ivec2(1090650112, 574916769);
  const ivec2 char_W = ivec2(-1522204672, 574916946);
  const ivec2 char_X = ivec2(1145602048, 574902337);
  const ivec2 char_Y = ivec2(-2130575360, 574902336);
  const ivec2 char_Z = ivec2(1078951936, 1044398144);
  const ivec2 char_bracketleft = ivec2(1083113472, 1007161376);
  const ivec2 char_backslash = ivec2(67108864, 266305);
  const ivec2 char_bracketright = ivec2(34045952, 505430145);
  const ivec2 char_asciicircum = ivec2(0, 136873984);
  const ivec2 char_underscore = ivec2(1015808, 0);
  const ivec2 char_quotereversed = ivec2(0, 135282688);
  const ivec2 char_a = ivec2(-1001455616, 28931);
  const ivec2 char_b = ivec2(608665600, 33847570);
  const ivec2 char_c = ivec2(542048256, 61456);
  const ivec2 char_d = ivec2(609157120, 541126930);
  const ivec2 char_e = ivec2(-532217856, 28947);
  const ivec2 char_f = ivec2(-2130575360, 269492448);
  const ivec2 char_g = ivec2(609161244, 61714);
  const ivec2 char_h = ivec2(608731136, 33847570);
  const ivec2 char_i = ivec2(-2130247680, 134230080);
  const ivec2 char_j = ivec2(-2130574332, 134225984);
  const ivec2 char_k = ivec2(-1031208960, 67670176);
  const ivec2 char_l = ivec2(-2130247680, 202383424);
  const ivec2 char_m = ivec2(-1521844224, 22866);
  const ivec2 char_n = ivec2(608731136, 30994);
  const ivec2 char_o = ivec2(608632832, 28946);
  const ivec2 char_p = ivec2(608665858, 30994);
  const ivec2 char_q = ivec2(609161248, 61714);
  const ivec2 char_r = ivec2(1082195968, 53344);
  const ivec2 char_s = ivec2(-1006141440, 61457);
  const ivec2 char_t = ivec2(-2130444288, 135295040);
  const ivec2 char_u = ivec2(609157120, 35090);
  const ivec2 char_v = ivec2(1115815936, 35089);
  const ivec2 char_w = ivec2(-1522204672, 35090);
  const ivec2 char_x = ivec2(-2104983552, 34976);
  const ivec2 char_y = ivec2(609161244, 35090);
  const ivec2 char_z = ivec2(-2138079232, 63616);
  const ivec2 char_braceleft = ivec2(-2129920000, 806363168);
  const ivec2 char_brokenbar = ivec2(-2130575360, 135274496);
  const ivec2 char_braceright = ivec2(-2130608128, 101720192);
  const ivec2 char_asciitilde = ivec2(0, 72630272);
  const ivec2 char_filledbox = ivec2(-405831680, 1048377843);
  const ivec2 char_sterling = ivec2(1083146240, 407375984);
  const ivec2 char_quotesingle = ivec2(0, 135274496);
  const ivec2 char_arrowleft = ivec2(1090519040, 1053168);
  const ivec2 char_onehalf = ivec2(-1543240648, 33818641);
  const ivec2 char_arrowright = ivec2(16777216, 1065457);
  const ivec2 char_arrowup = ivec2(-2130706432, 1077584);
  const ivec2 char_emdash = ivec2(0, 496);
  const ivec2 char_onequarter = ivec2(1175067680, 67637282);
  const ivec2 char_dblverticalbar = ivec2(1116012544, 338186401);
  const ivec2 char_threequarters = ivec2(1711938592, 101718082);
  const ivec2 char_divide = ivec2(16777216, 1049072);
  const ivec2 char_comma_saa5051 = ivec2(8454400, 0);
  const ivec2 char_period_saa5051 = ivec2(25362432, 0);
  const ivec2 char_colon_saa5051 = ivec2(65536, 32);
  const ivec2 char_semicolon_saa5051 = ivec2(8454400, 4096);
  const ivec2 char_section = ivec2(596119836, 474220770);
  const ivec2 char_Adieresis = ivec2(-465010688, 335573267);
  const ivec2 char_Odieresis = ivec2(608632832, 335573266);
  const ivec2 char_Udieresis = ivec2(608632832, 335579410);
  const ivec2 char_degree = ivec2(0, 407396352);
  const ivec2 char_adieresis = ivec2(-1001455616, 335573251);
  const ivec2 char_odieresis = ivec2(608632832, 2621666);
  const ivec2 char_udieresis = ivec2(609157120, 2621714);
  const ivec2 char_germandbls = ivec2(608600322, 203704530);
  const ivec2 char_currency = ivec2(1133019136, 35041);
  const ivec2 char_Eacute = ivec2(-531660800, 269547537);
  const ivec2 char_D_saa5052 = ivec2(1149698048, 474517794);
  const ivec2 char_L_saa5052 = ivec2(1083113472, 67637280);
  const ivec2 char_Aring = ivec2(-465010688, 134246675);
  const ivec2 char_eacute = ivec2(-532217856, 269512979);
  const ivec2 char_aring = ivec2(-1001455616, 134246659);
  const ivec2 char_ccedilla = ivec2(542050312, 61456);
  const ivec2 char_ugrave = ivec2(609157120, 68192530);
  const ivec2 char_agrave = ivec2(-1001455616, 68186371);
  const ivec2 char_ograve = ivec2(608632832, 68157666);
  const ivec2 char_egrave = ivec2(-532217856, 68186387);
  const ivec2 char_igrave = ivec2(-2130247680, 68157536);
  const ivec2 char_idieresis = ivec2(-2130247680, 335556672);
  const ivec2 char_edieresis = ivec2(-532217856, 335573267);
  const ivec2 char_ecircumflex = ivec2(-532217856, 136868115);
  const ivec2 char_ugrave_saa5054 = ivec2(609157120, 136349970);
  const ivec2 char_icircumflex = ivec2(-2130247680, 136839264);
  const ivec2 char_acircumflex = ivec2(-1001455616, 136868099);
  const ivec2 char_ocircumflex_saa5054 = ivec2(608632832, 136868114);
  const ivec2 char_ucircumflex = ivec2(609157120, 136839442);
  const ivec2 char_ccedilla_saa5054 = ivec2(542050328, 61456);

  float draw_char(vec2 coord, ivec2 char) {

  int pos_id = int(coord.x * 7.0) + int(coord.y * 9.0) * 7;

  int num = pos_id < 32 ? char.x : char.y;
  int val;

  if(pos_id < 32) {
    val = int(mod(float(num) / pow(2.0, float(pos_id)), 2.0));
  } else {
        // Handle the case where pos_id is greater than or equal to 32
        // by using a different bit manipulation technique.
    int shifted_pos_id = pos_id - 32;
    int pow_val = int(pow(2.0, float(shifted_pos_id)));
    val = (num / pow_val);
    val = val - (val / 2) * 2; // Use arithmetic to ensure val is 0 or 1
  }

  float col = val == 0 ? 0.0 : 1.0;

  return col;
}

// --------------------------------------------- Draw words

vec3 draw_text_pool(vec2 p, ivec2 text_box, vec3 text_coord) {
    // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[13];
  text_string_2[1] = ivec2(char_I);
  text_string_2[2] = ivec2(char_N);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_E);
  text_string_2[5] = ivec2(char_N);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_space);
  text_string_2[8] = ivec2(char_P);
  text_string_2[9] = ivec2(char_O);
  text_string_2[10] = ivec2(char_O);
  text_string_2[11] = ivec2(char_L);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];
  else if(charIndex == 10)
    current_char = text_string_2[10];
  else if(charIndex == 11)
    current_char = text_string_2[11];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_you(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[4];
  text_string_2[1] = ivec2(char_Y);
  text_string_2[2] = ivec2(char_O);
  text_string_2[3] = ivec2(char_U);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_hedger(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[7];
  text_string_2[1] = ivec2(char_H);
  text_string_2[2] = ivec2(char_E);
  text_string_2[3] = ivec2(char_D);
  text_string_2[4] = ivec2(char_G);
  text_string_2[5] = ivec2(char_E);
  text_string_2[6] = ivec2(char_R);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_party_a(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[8];
  text_string_2[1] = ivec2(char_P);
  text_string_2[2] = ivec2(char_A);
  text_string_2[3] = ivec2(char_R);
  text_string_2[4] = ivec2(char_T);
  text_string_2[5] = ivec2(char_Y);
  text_string_2[6] = ivec2(char_space);
  text_string_2[7] = ivec2(char_A);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_party_b(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[8];
  text_string_2[1] = ivec2(char_P);
  text_string_2[2] = ivec2(char_A);
  text_string_2[3] = ivec2(char_R);
  text_string_2[4] = ivec2(char_T);
  text_string_2[5] = ivec2(char_Y);
  text_string_2[6] = ivec2(char_space);
  text_string_2[7] = ivec2(char_B);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_intent_a(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[9];
  text_string_2[1] = ivec2(char_I);
  text_string_2[2] = ivec2(char_N);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_E);
  text_string_2[5] = ivec2(char_N);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_space);
  text_string_2[8] = ivec2(char_A);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}
vec3 draw_text_intent_b(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[9];
  text_string_2[1] = ivec2(char_I);
  text_string_2[2] = ivec2(char_N);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_E);
  text_string_2[5] = ivec2(char_N);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_space);
  text_string_2[8] = ivec2(char_B);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_liquidator(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

  // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[11];
  text_string_2[1] = ivec2(char_L);
  text_string_2[2] = ivec2(char_I);
  text_string_2[3] = ivec2(char_Q);
  text_string_2[4] = ivec2(char_U);
  text_string_2[5] = ivec2(char_I);
  text_string_2[6] = ivec2(char_D);
  text_string_2[7] = ivec2(char_A);
  text_string_2[8] = ivec2(char_T);
  text_string_2[9] = ivec2(char_O);
  text_string_2[10] = ivec2(char_R);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

  //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];
  else if(charIndex == 10)
    current_char = text_string_2[10];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_execute(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[8];
  text_string_2[1] = ivec2(char_E);
  text_string_2[2] = ivec2(char_X);
  text_string_2[3] = ivec2(char_E);
  text_string_2[4] = ivec2(char_C);
  text_string_2[5] = ivec2(char_U);
  text_string_2[6] = ivec2(char_T);
  text_string_2[7] = ivec2(char_E);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_liquidate(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[10];
  text_string_2[1] = ivec2(char_L);
  text_string_2[2] = ivec2(char_I);
  text_string_2[3] = ivec2(char_Q);
  text_string_2[4] = ivec2(char_U);
  text_string_2[5] = ivec2(char_I);
  text_string_2[6] = ivec2(char_D);
  text_string_2[7] = ivec2(char_A);
  text_string_2[8] = ivec2(char_T);
  text_string_2[9] = ivec2(char_E);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_minus_btc(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[7];
  text_string_2[1] = ivec2(char_emdash);
  text_string_2[2] = ivec2(char_one);
  text_string_2[3] = ivec2(char_space);
  text_string_2[4] = ivec2(char_B);
  text_string_2[5] = ivec2(char_T);
  text_string_2[6] = ivec2(char_C);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_plus_btc(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[7];
  text_string_2[1] = ivec2(char_plus);
  text_string_2[2] = ivec2(char_one);
  text_string_2[3] = ivec2(char_space);
  text_string_2[4] = ivec2(char_B);
  text_string_2[5] = ivec2(char_T);
  text_string_2[6] = ivec2(char_C);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_btc_short(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

  // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[11];
  text_string_2[1] = ivec2(char_one);
  text_string_2[2] = ivec2(char_B);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_C);
  text_string_2[5] = ivec2(char_space);
  text_string_2[6] = ivec2(char_S);
  text_string_2[7] = ivec2(char_H);
  text_string_2[8] = ivec2(char_O);
  text_string_2[9] = ivec2(char_R);
  text_string_2[10] = ivec2(char_T);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

  //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];
  else if(charIndex == 10)
    current_char = text_string_2[10];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_btc_long(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

  // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[10];
  text_string_2[1] = ivec2(char_one);
  text_string_2[2] = ivec2(char_B);
  text_string_2[3] = ivec2(char_T);
  text_string_2[4] = ivec2(char_C);
  text_string_2[5] = ivec2(char_space);
  text_string_2[6] = ivec2(char_L);
  text_string_2[7] = ivec2(char_O);
  text_string_2[8] = ivec2(char_N);
  text_string_2[9] = ivec2(char_G);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

  //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];
  else if(charIndex == 5)
    current_char = text_string_2[5];
  else if(charIndex == 6)
    current_char = text_string_2[6];
  else if(charIndex == 7)
    current_char = text_string_2[7];
  else if(charIndex == 8)
    current_char = text_string_2[8];
  else if(charIndex == 9)
    current_char = text_string_2[9];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}




vec3 draw_text_lock(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[5];
  text_string_2[1] = ivec2(char_L);
  text_string_2[2] = ivec2(char_O);
  text_string_2[3] = ivec2(char_C);
  text_string_2[4] = ivec2(char_K);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}

vec3 draw_text_dash(vec2 p, ivec2 text_box, vec3 text_coord) {
  // Normalized pixel coordinates (from 0 to 1)
  vec2 coord = p;
  coord.x = -coord.x;
  coord /= text_coord.x;
  coord.x += text_coord.y;
  coord.y += text_coord.z;

    // Check if the character is outside the visible area
  if(coord.x < 0.0 || coord.x >= 1.0 || coord.y < 0.0 || coord.y >= 1.0) {
    return vec3(0.0); // Return transparent color for characters outside the screen
  }

  coord.x *= float(text_box.x);
  coord.y *= float(text_box.y);
  int charIndex = int(coord.x) + (text_box.y - int(coord.y) - 2) * text_box.x;
  coord.x -= float(int(coord.x));
  coord.y -= float(int(coord.y));

  ivec2 text_string_2[5];
  text_string_2[1] = ivec2(char_emdash);
  text_string_2[2] = ivec2(char_emdash);
  text_string_2[3] = ivec2(char_emdash);
  text_string_2[4] = ivec2(char_emdash);

  ivec2 current_char = text_string_2[0]; // Initialize with a default character (e.g., space)

    //  using [charIndex]
  if(charIndex == 1)
    current_char = text_string_2[1];
  else if(charIndex == 2)
    current_char = text_string_2[2];
  else if(charIndex == 3)
    current_char = text_string_2[3];
  else if(charIndex == 4)
    current_char = text_string_2[4];

  vec3 col = vec3(draw_char(coord, current_char));

  return col;
}


 // Includes and constants
#define SCA(a)      vec2(sin(a), cos(a))
#define HSV2RGB_K  vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0)
#define HSV2RGB(c) (c.z * mix(HSV2RGB_K.xxx, clamp(abs(fract(c.xxx + HSV2RGB_K.xyz) * 6.0 - HSV2RGB_K.www) - HSV2RGB_K.xxx, 0.0, 1.0), c.y))


ivec2 text_box_chars = ivec2(13, 7);
vec3 text_coord; // Scale.xy   Position.zw


vec3 glow_color;
float text_selector = 0.0;
float text_selector_2 = 0.0;
vec2 tri_pos;
float tri_scl = 1.0;
float tri_vis = 1.0;
float tri2_vis = 1.0;
float animSection1 = iAnimProgress_1.x; //List Header
float animSection2 = iAnimProgress_1.y; //Create Intent
float animSection3 = iAnimProgress_1.z; //Send Intent
float animSection4 = iAnimProgress_2.x; //Hedger sees
float animSection5 = iAnimProgress_2.y; //Hedger claims
float animSection6 = iAnimProgress_2.z; //Trade created
float animSection7 = iAnimProgress_3.x; //collateral locked
float animSection8 = iAnimProgress_3.y; //watchdogs
float animSection9 = iAnimProgress_3.z;
float animSection10 = iAnimProgress_4.x;
float animSection11 = iAnimProgress_4.y;

const float k = sqrt(3.0);
  // Define common variables
  vec2 p;
  vec2 p_text;
  float dt;
vec2 fadein_fadeout = vec2(clamp(animSection1*2.0,0.0,1.0),clamp(animSection8*2.0,0.0,1.0));
vec3 anim_1(vec3 col, vec3 ro, vec3 rd) {
  glow_color = vec3(0.008, 0.001, 0.001);
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  p = pp.xy * 0.5;
  p.y -= 0.58;
  
  vec3 glow_col = HSV2RGB(vec3(0.005, 0.9, 0.01));
  p = vec2(abs(p.x) - 1.0, p.y + 1.0 / k);
  p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
  p.x -= clamp(p.x, -2.0, 0.0);
  dt = -length(p) * sign(p.y);
  col = mix((dt < -0.0) ? fillColor : col, col, 0.0);
  col += glow_col / max(abs(dt), 0.001);
  return col;
}


vec3 anim_2(vec3 col, vec3 ro, vec3 rd) {


  // Triangle positions and scales
  vec3 glow_col = HSV2RGB(vec3(0.005, 0.9, 0.01));
  float t = -(dot(ro, vec3(0.0, 0.0, 1.0)) - 2.0) / dot(rd, vec3(0.0, 0.0, 1.0));
  //add text pool

  p_text = (ro + rd * t).xy * 0.5;
  p_text.y -= 0.6;
  text_coord = vec3(1.0, 0.49, 0.47); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(0.0, 0.5, 1.0)), draw_text_pool(p_text, text_box_chars, text_coord)*(fadein_fadeout.x-fadein_fadeout.y));

  /////YOU TRI
  p = (ro + rd * t).xy * 1.0;
  p.y -= 0.58;
  p.x -= 1.0+fadein_fadeout.x-animSection3;
  p_text = p;
  p.x = abs(p.x) - 1.0;
  p.y = p.y + 1.0 / k;
  p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
  p.x -= clamp(p.x, -2.0, 0.0);
  dt = -length(p) * sign(p.y);
  col = mix((dt < -0.0) ? vec3(0.005, 0.0, 0.0) : col, col, 1.0-(fadein_fadeout.x-fadein_fadeout.y));
  glow_col = HSV2RGB(vec3(0.005, 0.5, 0.01*(fadein_fadeout.x-fadein_fadeout.y)));
  col += glow_col / max(abs(dt), 0.001);
  text_coord = vec3(1.5, 0.2, 1.05); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0)), draw_text_you(p_text, text_box_chars, text_coord)*(fadein_fadeout.x-animSection3));
  text_coord = vec3(1.5, 0.33, 1.05); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0)), draw_text_party_a(p_text, text_box_chars, text_coord)*animSection3);
  text_coord = vec3(1.5, 0.39-(sin(animSection6*3.142))*0.5, 0.87); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0)), draw_text_intent_a(p_text, text_box_chars, text_coord)*(animSection2-animSection6));
  text_coord = vec3(1.5, 0.42-(sin(animSection6*3.142))*0.5, 0.87); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(0.0, 0.0, 1.0)), draw_text_btc_long(p_text, text_box_chars, text_coord)*(animSection6-fadein_fadeout.y));

  text_coord = vec3(2.0, -0.29, 0.47); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(0.0, 0.0, 0.6)), draw_text_lock(p_text, text_box_chars, text_coord)*(animSection7-fadein_fadeout.y));
 
  /////HEDGER TRI
  p = (ro + rd * t).xy * 1.0;
  p.y -= 0.58;
  p.x += 1.0+fadein_fadeout.x-animSection5;
  p_text = p;
  p.x = abs(p.x) - 1.0;
  p.y = p.y + 1.0 / k;
  p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
  p.x -= clamp(p.x, -2.0, 0.0);
  dt = -length(p) * sign(p.y);
  col = mix((dt < -0.0) ? vec3(0.005, 0.0, 0.0) : col, col, 1.0-(fadein_fadeout.x-fadein_fadeout.y));
  glow_col = HSV2RGB(vec3(0.00, 1.0, 0.01*(fadein_fadeout.x-animSection2*0.5+animSection4*0.5-fadein_fadeout.y)));
  col += glow_col / max(abs(dt), 0.001);
  text_coord = vec3(1.5, 0.3, 1.05); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(0.00, 1.0, 1.0-animSection2*0.2+animSection4*0.2)), draw_text_hedger(p_text, text_box_chars, text_coord)*(fadein_fadeout.x-animSection5));
  text_coord = vec3(1.5, 0.33, 1.05); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(0.00, 1.0-fadein_fadeout.y, 1.0)), draw_text_party_b(p_text, text_box_chars, text_coord)*animSection5);
  text_coord = vec3(1.5, 0.39+(sin(animSection6*3.142))*0.5, 0.87); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(0.00, 1.0, 1.0)), draw_text_intent_b(p_text, text_box_chars, text_coord)*(animSection5-animSection6));
  text_coord = vec3(1.5, 0.46+(sin(animSection6*3.142))*0.5, 0.87); // Scale.x   Position.yz
  col = mix(col, HSV2RGB(vec3(0.00, 1.0, 1.0)), draw_text_btc_short(p_text, text_box_chars, text_coord)*(animSection6-fadein_fadeout.y));

  
  return col;
}






vec3 eyeRender(vec3 col, vec2 p, float vis) {
  // Calculate blink
  float eyeBlink = smoothstep(-0.28, 0.2, mod(iTime, 0.0));
  eyeBlink -= smoothstep(0.28, 0.4, mod(iTime, 2.5));
  // REPLACEMENT
  vec2 rotatedP = vec2(-p.y + 0.2, p.x);
  // Calculate Almond Eye
  float bl = 1.0;
  bl *= vis;
  float k = -clamp(bl * bl, 0.06, 1.0);
  vec2 pos = vec2(-4.0 * rotatedP.y, 4.0 * rotatedP.x);
  pos = abs(pos);
  float ik = 1.0 / k;
  float parabola_p = ik * (pos.y - 1.1 * ik) / 3.0;
  float parabola_q = 0.25 * ik * ik * pos.x;
  float parabola_h = parabola_q * parabola_q - parabola_p * parabola_p * parabola_p;
  float parabola_r = sqrt(abs(parabola_h));
  float parabola_x = (parabola_h > 0.0) ? pow(parabola_q + parabola_r, 1.0 / 3.0) - pow(abs(parabola_q - parabola_r), 1.0 / 3.0) * sign(parabola_r - parabola_q) : 2.0 * cos(atan(parabola_r, parabola_q) / 3.0) * sqrt(parabola_p);

  float sdEye = length(pos - vec2(parabola_x, k * parabola_x * parabola_x)) * sign(pos.x - parabola_x) - bl + 0.06;

  // Apply smoothstep to color using sdEye
  col += smoothstep(0.015, 0.025, abs(sdEye));
  // Eye core creation and reposition
  vec2 diff = 2.0 * rotatedP;
  float distance = length(diff) - 0.3 - 2.0 * smoothstep(0.895, 0.9, 0.0);
  float eyeMask = max(distance, sdEye);
  col = min(col, smoothstep(-0.01, 0.0, eyeMask * vis));
  return col;
}


vec3 anim_3(vec3 col, vec3 ro, vec3 rd) {
  vec3 eyecolor = HSV2RGB(vec3(0.0, 0.0, 1.0));
  vec2 p_rota;
  tri_scl = 2.0;
  glow_color = vec3(0.008, 0.001, 0.001);
  text_selector = 0.0;
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  p = pp.xy * 0.5;

  vec2 anim_time_liq = vec2(sin(iTime/2.0), cos(iTime/2.0));
  vec2 liq_quad_helper = vec2(smoothstep(anim_time_liq.x,0.0,1.0),smoothstep(anim_time_liq.y,0.0,1.0));
  float liq_quad1 = (1.0-liq_quad_helper.x)*liq_quad_helper.y;
  float liq_quad3 = anim_time_liq.x*(1.0-liq_quad_helper.y);
  float liq_quad2 = liq_quad_helper.x*liq_quad_helper.y;
  float liq_quad4 = (1.0-liq_quad_helper.x)*(1.0-liq_quad_helper.y);
  
  //text   PARTY A
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0)), draw_text_party_a(p, text_box_chars, vec3(0.75, 1.0, 0.66)));
  //text   PARTY B
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0)), draw_text_party_b(p, text_box_chars, vec3(0.75, -0.33, 0.66)));

  float tri_vis_1;
  vec2 pt_1 = p;
  vec2 anim_time_1 = vec2(sin(iTime), cos(iTime));
  vec2 quad_helper = vec2(smoothstep(anim_time_1.x,0.0,1.0),smoothstep(anim_time_1.y,0.0,1.0));
  float quad1 = (1.0-quad_helper.x)*quad_helper.y;
  float quad2 = quad_helper.x*quad_helper.y;
  float quad3 = quad_helper.x*(1.0-quad_helper.y);
  float quad4 = (1.0-quad_helper.x)*(1.0-quad_helper.y);


  pt_1 /= 0.5;
  pt_1.y -= 1.18;
  pt_1 -= vec2(1.5*anim_time_1.y*(quad1+quad2), 1.15 + 1.5*(anim_time_1.x+1.0)*(quad1+quad2));
  tri_vis_1 = (quad1*(1.0-anim_time_1.x))+quad2+quad3*(1.0-anim_time_1.y);
  p_rota = pt_1;
  

  vec3 glow_col = HSV2RGB(vec3(0.0, 0.0+(quad3/1.2), 0.005 * tri_vis_1));
  pt_1 = vec2(abs(pt_1.x) - 1.0, pt_1.y + 1.0 / k);
  pt_1 = (pt_1.x + k * pt_1.y > 0.0) ? vec2(pt_1.x - k * pt_1.y, -k * pt_1.x - pt_1.y) / 2.0 : pt_1;
  pt_1.x -= clamp(pt_1.x, -2.0, 0.0);
  dt = -length(pt_1) * sign(pt_1.y);
  col = mix((dt < -0.0) ? fillColor : col, col, 1.0 - tri_vis_1);
  col += glow_col / max(abs(dt), 0.001);

  col = mix(HSV2RGB(vec3(0.0, 0.0+(quad3/1.2), 1.0)), col, eyeRender(col, p_rota, tri_vis_1));
  //text   LIQUIDATOR
  col = mix(col, HSV2RGB(vec3(0.0, 0.0+(quad3/1.2), 1.0*(animSection8-animSection9))), draw_text_liquidator(p_rota, text_box_chars, vec3(1.5, 0.45, 1.0))* tri_vis_1);
  //text   EXECUTE
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0 *(animSection8-animSection9))), (draw_text_execute(p, text_box_chars, vec3(1.5, 0.35, 0.35))*(1.0-anim_time_1.y)*quad3*liq_quad1*liq_quad3)),
  //text   LIQUIDATE
  col = mix(col, HSV2RGB(vec3(0.0, 0.9, 1.0*(animSection8-animSection9) )), (draw_text_liquidate(p, text_box_chars, vec3(1.5, 0.42, 0.35))*(1.0-anim_time_1.y)*quad3)),
  //text   PLUS1000
    col = mix(col, HSV2RGB(vec3(0.4, 1.0, 1.5*(animSection8-animSection9))), (draw_text_plus_btc(p, text_box_chars, vec3(0.75, 1.0, 0.46 - anim_time_1.y / 6.0))*anim_time_1.x*quad3*liq_quad1*liq_quad3)),
  //text   MINUS1000
    col = mix(col, HSV2RGB(vec3(0.0, 1.0, 1.5*(animSection8-animSection9))), (draw_text_minus_btc(p, text_box_chars, vec3(0.75, -0.32, 0.46 - anim_time_1.y / 6.0))*anim_time_1.x*quad3*liq_quad3)+(draw_text_dash(p, text_box_chars, vec3(1.75, -0.05, 0.74 ))*anim_time_1.x*quad3*liq_quad3));
  //text   MINUS1000
  col = mix(col, HSV2RGB(vec3(0.0, 1.0, 1.5*(animSection8-animSection9))), (draw_text_minus_btc(p, text_box_chars, vec3(0.75, 1.0, 0.46 - anim_time_1.y / 6.0))*anim_time_1.x*quad3*liq_quad1)+(draw_text_dash(p, text_box_chars, vec3(1.75, 0.51, 0.74 ))*anim_time_1.x*quad3*liq_quad1));



  vec2 p_rota_2;
  float tri_vis_2;
  vec2 pt_2 = p;
  vec2 anim_time_2 = vec2(sin(iTime+3.14), cos(iTime+3.14));
  vec2 quad_helper_2 = vec2(smoothstep(anim_time_2.x,0.0,1.0),smoothstep(anim_time_2.y,0.0,1.0));
  float quad1_2 = (1.0-quad_helper_2.x)*quad_helper_2.y;
  float quad2_2 = quad_helper_2.x*quad_helper_2.y;
  float quad3_2 = quad_helper_2.x*(1.0-quad_helper_2.y);
  float quad4_2 = (1.0-quad_helper_2.x)*(1.0-quad_helper_2.y);


  pt_2 /= 0.5;
  pt_2.y -= 1.18;
  pt_2 -= vec2(1.5*anim_time_2.y*(quad1_2+quad2_2), 1.15 + 1.5*(anim_time_2.x+1.0)*(quad1_2+quad2_2));
  tri_vis_2 = (quad1_2*(1.0-anim_time_2.x))+quad2_2+quad3_2*(1.0-anim_time_2.y);
  p_rota_2 = pt_2;
  

  vec3 glow_col_2 = HSV2RGB(vec3(0.0, 0.0, 0.005 * tri_vis_2));
  pt_2 = vec2(abs(pt_2.x) - 1.0, pt_2.y + 1.0 / k);
  pt_2 = (pt_2.x + k * pt_2.y > 0.0) ? vec2(pt_2.x - k * pt_2.y, -k * pt_2.x - pt_2.y) / 2.0 : pt_2;
  pt_2.x -= clamp(pt_2.x, -2.0, 0.0);
  dt = -length(pt_2) * sign(pt_2.y);
  col = mix((dt < -0.0) ? fillColor : col, col, 1.0 - tri_vis_2);
  col += glow_col_2 / max(abs(dt), 0.001);
  col = mix(HSV2RGB(vec3(0.0, 0.0, 1.0)), col, eyeRender(col, p_rota_2, tri_vis_2));
  //text   LIQUIDATOR
  col = mix(col, HSV2RGB(vec3(0.0, 0.0, 1.0)), draw_text_liquidator(p_rota_2, text_box_chars, vec3(1.5, 0.45, 1.0)) * tri_vis_2);
  //text   EXECUTE
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0 )), (draw_text_execute(p, text_box_chars, vec3(1.5, 0.35, 0.35))*(1.0-anim_time_2.y)*quad3_2)),
  //text   BTC PLUS
    col = mix(col, HSV2RGB(vec3(0.4, 1.0, 1.5)), (draw_text_plus_btc(p, text_box_chars, vec3(0.75, -0.32, 0.46 - anim_time_2.y / 6.0))*(1.0-anim_time_2.y)*quad3_2)),
  //text   MINUS100
    col = mix(col, HSV2RGB(vec3(0.0, 1.2, 1.5)), (draw_text_minus_btc(p, text_box_chars, vec3(0.75, 1.0, 0.46 - anim_time_2.y / 6.0))*(1.0-anim_time_2.y)*quad3_2));


  return col;
}
vec3 anim_4(vec3 col, vec3 ro, vec3 rd) {

  vec2 anim_time_1 = vec2(sin(iTime), cos(iTime));
  vec2 quad_helper = vec2(smoothstep(anim_time_1.x,0.0,1.0),smoothstep(anim_time_1.y,0.0,1.0));
  float quad1 = (1.0-quad_helper.x)*quad_helper.y;
  float quad2 = quad_helper.x*quad_helper.y;
  float quad3 = quad_helper.x*(1.0-quad_helper.y);
  float quad4 = (1.0-quad_helper.x)*(1.0-quad_helper.y);


  glow_color = vec3(0.008, 0.001, 0.001);
  vec3 fillColor = vec3(0.005, 0.0, 0.0);
  const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);
  float tpd = -(dot(ro, tpdim.xyz) + tpdim.w) / dot(rd, tpdim.xyz);
  vec3 pp = ro + rd * tpd;
  vec3 glow_col = HSV2RGB(vec3(0.005, 0.9, 0.01));

  // Half right
  p = pp.xy * 0.5;

  p.y -= 0.58;
  p.x -= ((animSection9-0.1)-(animSection10-0.09))*0.1;
  float smoothStepRight = 1.0 - smoothstep(0.0, 0.002, abs(p.x));
  if (p.x > 0.0) {
    p = vec2(abs(p.x) - 1.0, p.y + 1.0 / k);
    p = (p.x + k * p.y > 0.0) ? vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0 : p;
    p.x -= clamp(p.x, -2.0, 0.0);
    dt = -length(p) * sign(p.y);
    col = mix((dt < 0.0) ? fillColor : col, col, smoothStepRight);

    col += glow_col / max(abs(dt), 0.001) ;
    
  }
vec2 p2;
  // Half left
  p2 = pp.xy * 0.5;
  col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0-min(animSection10*2.0,1.0))), draw_text_party_a(p2, text_box_chars, vec3(0.75, 0.985+((animSection9/7.0)-(animSection10/3.0)), 0.66)));
  col = mix(col, HSV2RGB(vec3(0.0, 1.0, 1.5)), (draw_text_minus_btc(p2, text_box_chars, vec3(0.75, 1.08, 0.46 - anim_time_1.y / 6.0))*(1.0-anim_time_1.y)*quad3*(animSection9-animSection10))),
  col = mix(col, HSV2RGB(vec3(0.4, 1.0, 1.5)), (draw_text_plus_btc(p2, text_box_chars, vec3(0.75, 1.08, 0.46 + anim_time_1.y / 6.0))*(1.0+anim_time_1.y)*quad1*(animSection9-animSection10))),

  p2.y -= 0.58;
  p2.x += ((animSection9-0.1)-(animSection10-0.09))*0.1;
  float smoothStepLeft = 1.0 - smoothstep(0.0, 0.002, abs(p2.x));
  if(p2.x < 0.0){
    p2 = vec2(abs(p2.x) - 1.0, p2.y + 1.0 / k);
    p2 = (p2.x + k * p2.y > 0.0) ? vec2(p2.x - k * p2.y, -k * p2.x - p2.y) / 2.0 : p2;
    p2.x -= clamp(p2.x, -2.0, 0.0);
    dt = -length(p2) * sign(p2.y);
    col = mix((dt < 0.0) ? fillColor : col, col, smoothStepLeft);
    col = mix(col, HSV2RGB(vec3(1.0, 0.0, 1.0-min(animSection10*2.0,1.0))), draw_text_party_b(p, text_box_chars, vec3(0.75, -0.32-((animSection9/4.0)-(animSection10/3.0)), 1.43)));
    col = mix(col, HSV2RGB(vec3(0.4, 1.0, 1.5)), (draw_text_plus_btc(p, text_box_chars, vec3(0.75, -0.58, 1.26 - anim_time_1.y / 6.0))*(1.0-anim_time_1.y)*quad3*(animSection9-animSection10))),
    col = mix(col, HSV2RGB(vec3(0.0, 1.0, 1.5)), (draw_text_minus_btc(p, text_box_chars, vec3(0.75, -0.58, 1.26 + anim_time_1.y / 6.0))*(1.0+anim_time_1.y)*quad1*(animSection9-animSection10))),

    col += glow_col / max(abs(dt), 0.001) ;
 
  }

  return col;
}


// Precompute constant values
const vec3 sunDir = normalize(vec3(0.0, -2.0, 20.0));
vec3 sunCol = HSV2RGB(vec3(0.01, 0.5, 0.002-(animSection1*0.002)+(animSection8*0.00015)));
const vec3 skyBaseCol = HSV2RGB(vec3(1.0, 0.00, 0.008));
const vec3 gcol = HSV2RGB(vec3(1.0, 0.4, 0.008));
const vec3 airColor = HSV2RGB(vec3(0.97, 0.0, 0.1));

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  const float fov = 2.0;
  vec3 ro;
  vec3 la;
// -------------------Horizontal mode

if (iResolution.x>iResolution.y){
  // Camera location right - left
  ro = vec3(0.0+animSection1*2.0+animSection8*0.9-animSection9*0.9-animSection10*1.0,
  //Camera location up - down
   0.5+animSection10*0.5,
   //Camera location forth - back
   -5.0-animSection8*0.5+animSection9*0.5+animSection10*5.6);
  // Camrea look right - left
  la = vec3(0.0+animSection1*2.0+animSection8*0.9-animSection9*0.9,
  // Camrea look up - down
   1.5+animSection8*0.5-animSection9*0.5-animSection10*0.48,
  // Camrea look forth - back
   0.0+animSection10*10.0);
// -------------------Vertical mode
}else{
  // Camera location right - left
  ro = 1.0 * vec3(0.0+animSection10*2.0,
  //Camera location up - down
   0.5,
  //Camera location forth - back
   -11.0+animSection8*2.9+animSection10*6.48);
  // Camrea look right - left
  la = vec3(0.0+animSection10*1.9,
  // Camrea look up - down
  4.0-animSection8*0.9-animSection10*2.0,
  // Camrea look forth - back
  0.0);
};


  vec3 up = vec3(0.0, 1.0, 0.0);
  vec3 ww = normalize(la - ro);
  vec3 uu = normalize(cross(up, ww));
  vec3 vv = cross(ww, uu);

  vec2 q = (fragCoord / iResolution.xy - 0.5) * 2.0;
  vec2 p = q * vec2(iResolution.x / iResolution.y, 1.0);
  vec2 pp = p;

  vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);

  vec3 col = skyBaseCol;

  float sunDot = dot(sunDir, rd);
  col += sunCol / pow(1.002 - sunDot, 1.9);

  col += gcol * 0.3 / max(abs(rd.y), 0.001);
  col += airColor;

  const vec3 gpn = vec3(0.0, 1.0, 0.0);
  const float gpdimW = 0.0;
  float gpdimDot = dot(rd, gpn);

  float gpd = -(dot(ro, gpn) + gpdimW) / gpdimDot;

  if (gpd < 0.0) {
    col = col;
  } else {
    vec3 gp = ro + rd * gpd;
    float gpfre = 1.15-(animSection1*0.2)+(animSection8*0.2) + gpdimDot;
    gpfre = gpfre * gpfre * gpfre * gpfre;

    vec3 grr = reflect(rd, gpn);

    vec2 ggp = gp.xz;
    ggp.y += iTime;
    float dfy = dFdy(ggp.y);
    float gcf = sin(ggp.x) * sin(ggp.y);

    vec2 c = floor(ggp);
    ggp = mod(ggp + vec2(0.5), vec2(1.0)) - vec2(0.5);

    float ggd = min(abs(ggp.x), abs(ggp.y));

    vec3 gcol = HSV2RGB(vec3(0.01 * gcf, 0.7, 0.005-(animSection1*0.004)));

    vec3 rcol = skyBaseCol;



    float rsunDot = dot(sunDir, grr);
    rcol += sunCol / pow(1.002 - rsunDot, 1.9);

    if(animSection9<0.1)
    rcol = anim_1(rcol, gp, grr);
    if(animSection1>0.1 && animSection8<0.5)
    rcol = anim_2(rcol, gp, grr);
    else if(animSection8>=0.5&&animSection9<0.1)
    rcol = anim_3(rcol, gp, grr);
    else if(animSection9>=0.1)
    rcol = anim_4(rcol, gp, grr);


    rcol += gcol * 0.3 / max(abs(grr.y), 0.001);
    rcol += airColor;


    float maxVal = max(ggd, 0.0 + 0.25 * dfy);
    float expVal = exp(-0.25 * gpd);
    col = gcol / maxVal * expVal;
    col += rcol * gpfre / 2.0;
  }
  if(animSection9<0.1)
  col = anim_1(col, ro, rd);
  if(animSection1>0.1 && animSection8<0.5)
  col = anim_2(col, ro, rd);
  else if(animSection8>=0.5&&animSection9<0.1)
  col = anim_3(col, ro, rd);
  else if(animSection9>=0.1)
  col = anim_4(col, ro, rd);

  fragColor = vec4(col, 1.0);
}

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}
</script>

<script src="./threeJsHome.js"></script>